{"ctext": "// from header\n/*\n#ifndef SIMPLE_XML_H_\n#define SIMPLE_XML_H_\ntypedef struct XMLElement {\n  char* tag_name;\n  char* value;\n  struct XMLElement* parent;\n  struct Vector* children; \n} XMLElement;\nXMLElement* XMLElement_create(XMLElement *e, char* tag_name, char* value);\nvoid XMLElement_release(XMLElement *e);\nXMLElement* parse_xml(char *text);\n#endif\n\n*/\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include \"simple_vector.h\"\n#include \"simple_xml.h\"\nXMLElement* XMLElement_create(XMLElement *e, char* tag_name, char* value) {\n  e = malloc(sizeof(XMLElement));   \n  e->tag_name = tag_name;\n  e->value = value;\n  e->parent = NULL;\n  e->children = vector_create(e->children);\n  return e;\n}\nvoid XMLElement_release(XMLElement *e) {\n  e->parent = NULL;\n  free(e->tag_name);\n  free(e->value);\n  vector_release(e->children);\n  free(e);\n  e = NULL;\n}\n#define BEGIN_TAG_TOKEN '<'\n#define END_TAG_TOKEN '>'\n#define SPLASH_TOKEN '/'\ntypedef enum {\n  BEGIN_OPEN_TAG = 0,\n  BEGIN_CLOSE_TAG,\n  END_TAG, \n  TEXT = 3,\n} XMLTokenType;\ntypedef struct XMLToken {\n  XMLTokenType type;\n  char* data;\n} XMLToken;\ntypedef enum {\n  STATE1 = 0,\n  STATE2,\n  STATE3,\n  STATE4,\n  STATE5,\n  STATE6,\n  STATE7,\n  STATE8,\n  STATE_ERROR\n} ParseState;\nstatic ParseState state_translate[8][4] = {\n  \n  { STATE2,         STATE_ERROR,      STATE_ERROR, STATE_ERROR }, \n  { STATE_ERROR,    STATE_ERROR,      STATE_ERROR, STATE3 },      \n  { STATE_ERROR,    STATE_ERROR,      STATE4,      STATE_ERROR }, \n  { STATE2,         STATE_ERROR,      STATE_ERROR, STATE5 },      \n  { STATE_ERROR,    STATE6,           STATE_ERROR, STATE_ERROR }, \n  { STATE_ERROR,    STATE_ERROR,      STATE_ERROR, STATE7 },      \n  { STATE_ERROR,    STATE_ERROR,      STATE8,      STATE_ERROR }, \n  { STATE2,         STATE6,           STATE_ERROR, STATE_ERROR }, \n};\ntypedef struct XMLParser {\n  char* _input;\n  int _pos;\n  int _depth;\n  ParseState state;\n  Vector* value_stack;\n  Vector* tag_stack;\n  Vector* element_stack;\n} XMLParser;\nstatic XMLParser* XMLParser_create(XMLParser *p) {\n  p = malloc(sizeof(XMLParser));\n  p->_depth = 0;\n  p->state = STATE1;\n  p->tag_stack = vector_create(p->tag_stack);\n  p->value_stack = vector_create(p->value_stack);\n  p->element_stack = vector_create(p->element_stack);\n  return p;\n}\nstatic void XMLParser_release(XMLParser *p) {\n  vector_release(p->element_stack);\n  vector_release(p->value_stack);\n  vector_release(p->tag_stack);\n  free(p);\n  p = NULL;\n}\nstatic XMLToken* parser_get_text_token(XMLParser* parser, int from, int to) {\n  XMLToken* token;\n  int str_size;\n  token = malloc(sizeof(XMLToken)); \n  token->type = TEXT;\n  \n  \n  while (parser->_input[from] == ' ') from++;\n  while (parser->_input[to] == ' ') to--;\n  \n  token->type = TEXT;\n  if (to >= from) {\n    str_size = to - from + 1;\n    token->data = (char *)malloc(sizeof(char) * (str_size + 1));\n    strncpy(token->data, parser->_input + from, str_size);\n    token->data[str_size] = '\\0';\n  } else {\n    token->data = NULL;\n  }\n  return token; \n}\nstatic XMLToken* parser_get_next_token(XMLParser *parser) {\n  int length, begin_pos;\n \n  begin_pos = parser->_pos; \n  length = strlen(parser->_input);\n  if (begin_pos >= length)\n    return NULL;\n  while (parser->_pos < length) {\n    char ch;\n    ch = parser->_input[parser->_pos];\n    parser->_pos++;\n    switch(ch) {\n      case BEGIN_TAG_TOKEN: {\n        if (parser->_pos >  begin_pos + 1) {\n          parser->_pos--;\n          return parser_get_text_token(parser, begin_pos, parser->_pos - 1);\n        } else {\n          char next_char = parser->_input[parser->_pos];\n          if (next_char == SPLASH_TOKEN) {\n            XMLToken *token;\n            token = malloc(sizeof(XMLToken));\n            token->type = BEGIN_CLOSE_TAG;\n            parser->_pos++;\n            return token;\n          } else {\n            XMLToken *token;\n            token = malloc(sizeof(XMLToken));\n            token->type = BEGIN_OPEN_TAG;\n            return token;\n          }\n        }\n      }\n      case END_TAG_TOKEN: \n        if (parser->_pos > begin_pos + 1) {\n          parser->_pos--;\n          return parser_get_text_token(parser, begin_pos, parser->_pos - 1);\n        } else {\n          XMLToken *token;\n          token = malloc(sizeof(XMLToken));\n          token->type = END_TAG;\n          return token;\n        }\n      default:\n        break;\n    }\n  }\n  \n  return parser_get_text_token(parser, begin_pos, parser->_pos - 1);  \n}\ntypedef struct StackElement {\n  XMLElement *element;\n  int depth; \n} StackElement;\nstatic StackElement* StackElement_create(StackElement *se) {\n  se = malloc(sizeof(StackElement));\n  return se;\n}\nstatic void StackElement_release(StackElement *se) {\n  free(se);\n  se = NULL;\n} \nXMLElement* parse_xml_from_text(char *text) {\n  XMLToken *token;\n  XMLParser *parser;\n  parser = XMLParser_create(parser);\n  parser->_input = text;\n  parser->_pos = 0;\n  parser->state = STATE1;\n  while (1) {\n    ParseState state;\n    token = parser_get_next_token(parser); \n    if (token == NULL) break;\n    if (token->type == TEXT && token->data == NULL) \n      continue;\n    \n    state = state_translate[parser->state][token->type];\n    if (state != STATE_ERROR) {\n      switch (parser->state) {\n        case STATE1:\n          break;\n        case STATE2:\n          if (token->type == TEXT) {\n            vector_push_back(parser->tag_stack, token->data);\n            parser->_depth++;\n          }\n          break;\n        case STATE3:\n          break;\n        case STATE4:\n          vector_push_back(parser->value_stack, token->data);\n          break;\n        case STATE5:\n          break;\n        case STATE6:\n          if (token->type == TEXT) {\n            assert(strcmp(token->data, vector_top_back(parser->tag_stack)) == 0); \n          }\n          break;\n        case STATE7:\n          if (token->type == END_TAG) {\n            char *current_tag, *current_value;\n            int i, length;\n            XMLElement *top;\n            XMLElement *current;\n            StackElement *se;\n            current_tag = vector_top_back(parser->tag_stack);\n            current_value = vector_top_back(parser->value_stack);\n            length = vector_size(parser->element_stack);\n            parser->_depth--;\n            current = XMLElement_create(current, current_tag, current_value);\n            se = StackElement_create(se);\n            se->element = current;\n            se->depth = parser->_depth;\n            \n            \n            for (i = 0; i < length; ++i) {\n              StackElement *elem = (StackElement *)vector_top_back(parser->element_stack);\n              if (elem->depth <= se->depth) break;\n              vector_push_front(current->children, elem->element);\n              vector_pop_back(parser->element_stack);\n            }\n            \n            \n            vector_push_back(parser->element_stack, se);\n            vector_pop_back(parser->tag_stack);\n            vector_pop_back(parser->value_stack);\n          }\n          break;\n        case STATE8:\n          break;\n        default:\n          break;\n      }\n    }\n    free(token);\n    if (state == STATE_ERROR)\n      assert(state != STATE_ERROR && \"error while parsing\");\n    parser->state = state; \n  } \n  StackElement* stackElem = (StackElement *) vector_top_back(parser->element_stack);\n  XMLElement *xmlElem = stackElem->element;\n  StackElement_release(stackElem);\n  XMLParser_release(parser);\n  return xmlElem;\n}\n", "rtext": "use std::rc::{Rc, Weak};\nuse std::cell::RefCell;\nuse crate::simple_vector::Vector;\n// Constants\nconst BEGIN_TAG_TOKEN: char = '<';\nconst END_TAG_TOKEN: char = '>';\nconst SPLASH_TOKEN: char = '/';\n// XML Element structure\npub struct XMLElement {\n    pub tag_name: String,\n    pub value: String,\n    pub parent: Option<Weak<RefCell<XMLElement>>>,\n    pub children: Vector<Rc<RefCell<XMLElement>>>,\n}\n// XML Token types\n#[derive(Debug, Clone, PartialEq)]\npub enum XMLTokenType {\n    BeginOpenTag,\n    BeginCloseTag,\n    EndTag,\n    Text,\n}\n// XML Token structure\npub struct XMLToken {\n    pub token_type: XMLTokenType,\n    pub data: Option<String>,\n}\n// Parser state\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum ParseState {\n    State1,\n    State2,\n    State3,\n    State4,\n    State5,\n    State6,\n    State7,\n    State8,\n    StateError,\n}\n// XML Parser structure\npub struct XMLParser {\n    input: String,\n    position: usize,\n    depth: usize,\n    state: ParseState,\n    tag_stack: Vector<String>,\n    value_stack: Vector<String>,\n    element_stack: Vector<StackElement>,\n}\n// Stack element for tracking elements during parsing\npub struct StackElement {\n    element: Rc<RefCell<XMLElement>>,\n    depth: usize,\n}\nimpl StackElement {\n    pub fn new(element: Rc<RefCell<XMLElement>>, depth: usize) -> Self {\n        StackElement { element, depth }\n    }\n    pub fn release(&mut self) {\n        unimplemented!()\n    }\n}\n// Public API functions\nimpl XMLElement {\n    /// Create a new XML element with the given tag name and value\n    pub fn new(tag_name: String, value: String) -> Rc<RefCell<XMLElement>> {\n        // Implementation omitted\n        unimplemented!()\n    }\n}\nimpl XMLParser {\n    /// Create a new XML parser\n    pub fn new() -> Self {\n        // Implementation omitted\n        unimplemented!()\n    }\n    /// Parse an XML string and return the root element\n    pub fn parse(&mut self, text: &str) -> Result<Rc<RefCell<XMLElement>>, String> {\n        // Implementation omitted\n        unimplemented!()\n    }\n    /// Get the next token from the input\n    fn get_next_token(&mut self) -> Option<XMLToken> {\n        // Implementation omitted\n        unimplemented!()\n    }\n    /// Get a text token from the specified range\n    fn get_text_token(&self, from: usize, to: usize) -> XMLToken {\n        // Implementation omitted\n        unimplemented!()\n    }\n    fn release(&mut self) {\n        // Implementation omitted\n        unimplemented!()\n    }\n}\n/// Parse XML from text and return the root element\npub fn parse_xml_from_text(text: &str) -> Result<Rc<RefCell<XMLElement>>, String> {\n    // Implementation omitted\n    unimplemented!()\n}"}
{"ctext": "// from header\n/*\n#ifndef HASH_H\n#define HASH_H\n#define RANDOM_SIZE 16\nvoid generate_random_data(char *buffer, int length);\nvoid generate_hash(const char *data, int length, unsigned char *hash);\n#endif \n\n*/\n#include \"../../include/crypto/hashing.h\"\n#include \"../../include/vm/commit.h\"\n#include <stdio.h>\n#include <openssl/sha.h>\n#include <openssl/rand.h>\n#include <time.h>\n#include <stdlib.h>\nvoid generate_random_data(char *word, int length) {\n    const char charset[] = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    const size_t charset_size = sizeof(charset) - 1;\n    for (int i = 0; i < length; i++) {\n        if (RAND_bytes((unsigned char *)&word[i], 1) != 1) {\n            fprintf(stderr, \"Error generating random byte.\\n\");\n            exit(EXIT_FAILURE);\n        }\n        \n        word[i] = charset[word[i] % charset_size];\n    }\n    word[length] = '\\0';  \n}\nvoid generate_hash(const char *data, int length, unsigned char *hash) {\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data, length);\n    SHA256_Final(hash, &sha256);\n}\n", "rtext": "pub const RANDOM_SIZE: usize = 16;\npub fn generate_random_data(buffer: &mut [u8]) {\n    unimplemented!()\n}\npub fn generate_hash(data: &[u8], hash: &mut [u8]) {\n    unimplemented!()\n}"}
{"ctext": "// from header\n/*\n#ifndef LOGGER_H\n#define LOGGER_H\n#define KNORMAL  \"\\x1B[0m\"\n#define KRED  \"\\x1B[31m\"\n#define KGREEN  \"\\x1B[32m\"\n#define KYELLOW  \"\\x1B[33m\"\n#define KBLUE  \"\\x1B[34m\"\n#define KMAGENTA  \"\\x1B[35m\"\n#define KCYAN  \"\\x1B[36m\"\n#define KWHITE  \"\\x1B[37m\"\n#define COLOR_BOLD  \"\\e[1m\"\n#define COLOR_OFF   \"\\e[m\"\nenum LOGGING_TAG {\n    INFO_TAG = 1,\n    ERROR_TAG = 2,\n    WARNING_TAG = 3\n};\nvoid logger(enum LOGGING_TAG tag, const char* message);\n#endif\n\n*/\n#include \"../../include/logging/logger.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include<string.h>\n#include<errno.h>\nvoid logger(enum LOGGING_TAG tag, const char* message) {\n   time_t now;\n   time(&now);\n   char* time_now = ctime(&now);\n   time_now[strlen(time_now) - 1] = 0;\n   switch(tag) {\n      case INFO_TAG:\n         printf(\"%s \" COLOR_BOLD \"[%s]\" COLOR_OFF \": %s\\n\", time_now, \"INFO\", message);\n         break;\n      case ERROR_TAG:\n         fprintf(stderr, \"%s \" KRED COLOR_BOLD \"[%s]\" COLOR_OFF KNORMAL \": %s (%s)\\n\", time_now, \"ERROR\", message, strerror(errno));\n         break;\n      case WARNING_TAG:\n         printf(\"%s \" COLOR_BOLD \"[%s]\" COLOR_OFF \": %s\\n\", time_now, \"WARNING\", message);\n         break;\n      default:\n   }\n}", "rtext": "pub const KNORMAL: &str = \"\\x1B[0m\";\npub const KRED: &str = \"\\x1B[31m\";\npub const KGREEN: &str = \"\\x1B[32m\";\npub const KYELLOW: &str = \"\\x1B[33m\";\npub const KBLUE: &str = \"\\x1B[34m\";\npub const KMAGENTA: &str = \"\\x1B[35m\";\npub const KCYAN: &str = \"\\x1B[36m\";\npub const KWHITE: &str = \"\\x1B[37m\";\npub const COLOR_BOLD: &str = \"\\x1B[1m\";\npub const COLOR_OFF: &str = \"\\x1B[m\";\npub enum LOGGING_TAG {\n    INFO_TAG = 1,\n    ERROR_TAG = 2,\n    WARNING_TAG = 3,\n}\npub fn logger(tag: LOGGING_TAG, message: &str) {\n    unimplemented!()\n}"}
{"ctext": "#include \"../include/cli/cli_main.h\"\nint main(int argc, char const *argv[]) {\n    run_cli(argc, argv);\n    return 0;\n}", "rtext": "pub const ARG_INIT: &str = \"init\";\npub const ARG_HELP: &str = \"--help\";\npub const ARG_HELP_SC: &str = \"-h\";\npub const ARG_ADD_CHANGES: &str = \"add\";\npub const ARG_COMMIT: &str = \"commit\";\npub const ARG_ROLLBACK: &str = \"rollback\";\npub fn main() {\n    unimplemented!()\n}\npub fn getting_help() {\n    unimplemented!()\n}\npub fn init_repository() {\n    unimplemented!()\n}\npub fn track_changes(n: i32, files: &Vec<&str>) {\n    unimplemented!()\n}\npub fn commit_changes() {\n    unimplemented!()\n}\npub fn rollback_changes(hash: &str) {\n    unimplemented!()\n}"}
{"ctext": "// from header\n/*\n#ifndef LJMM_H\n#define LJMM_H\n#include <unistd.h>\nint ljmm_init(void);\nvoid ljmm_let_OS_take_care_1G_2G(int turn_on);\nvoid ljmm_test_set_test_param(const char* map_file, void *sbrk0, int page_size);\n#endif\n\n*/\n#include <sys/mman.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <fcntl.h>  \n#include <stdio.h>  \n#include <string.h>\n#ifdef DEBUG\n    #include <stdlib.h>\n    #define ASSERT(c) if (!(c))\\\n        { fprintf(stderr, \"%s:%d Assert: %s\\n\", __FILE__, __LINE__, #c); abort(); }\n#else\n    #define ASSERT(c) ((void)0)\n#endif\n#define unlikely(x) __builtin_expect((x),0)\n#define likely(x)   __builtin_expect((x),1)\n#define REAL_MMAP __real_mmap64\n#define WRAP_MMAP __wrap_mmap64\nextern void * REAL_MMAP(void *addr, size_t length, int prot, int flags,\n                        int fd, off_t offset);\ntypedef struct {\n    uintptr_t   page_size;\n    uintptr_t   page_mask;\n    uintptr_t   addr_upbound;\n    uintptr_t   addr_lowbound;\n    char        *dummy_blk;\n    const char  *map_file; \n    char        *buffer;   \n    int          buf_len;\n    \n    char         OS_take_care_1G_2G;\n    char         init_succ;\n} ljmm_t;\nstatic ljmm_t ljmm;\nenum {\n    BUFFER_SZ           = 8192,\n    DUMMY_BLK_SZ        = 12,\n    ADDR_2G             = 0x80000000,\n    ADDR_1G             = 0x40000000,\n};\n__attribute__((constructor)) static void\nljmm_init(void) {\n    ljmm.OS_take_care_1G_2G =\n#if defined(STRESS_TEST)\n    0\n#else\n    1\n#endif\n    ;\n    ljmm.addr_lowbound = (uintptr_t)sbrk(0);\n    ljmm.addr_upbound  = ADDR_2G;\n    ljmm.page_size = sysconf(_SC_PAGESIZE);\n    ljmm.page_mask = ljmm.page_size - 1;\n    \n    char* p = REAL_MMAP(sbrk(0), DUMMY_BLK_SZ, PROT_READ|PROT_WRITE,\n                        MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n    if (unlikely(p == MAP_FAILED)) {\n        return;\n    }\n    ljmm.dummy_blk = p;\n    ljmm.map_file = \"/proc/self/maps\";\n    \n    p = REAL_MMAP(NULL, BUFFER_SZ, PROT_READ|PROT_WRITE,\n                  MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n    if (unlikely(p == MAP_FAILED)) {\n        return;\n    }\n    ljmm.buffer = p;\n    ljmm.init_succ = 1;\n}\n__attribute__((destructor)) static void\nljmm_finalize(void) {\n    if (ljmm.dummy_blk && ljmm.dummy_blk != MAP_FAILED) {\n        munmap(ljmm.dummy_blk, DUMMY_BLK_SZ);\n        ljmm.dummy_blk = NULL;\n        ljmm.map_file = NULL;\n    }\n    if (ljmm.buffer && ljmm.buffer != MAP_FAILED) {\n        munmap(ljmm.buffer, BUFFER_SZ);\n    }\n    ljmm.init_succ = 0;\n}\nstatic int\nread_maps_to_buffer(void) {\n    int fd = open(ljmm.map_file, 0);\n    if (fd == -1) {\n        return -1;\n    }\n    int len = read(fd, ljmm.buffer, BUFFER_SZ - 1);\n    if (len >= 0 && ljmm.buffer[len-1] != '\\n') {\n        ljmm.buffer[len++] = '\\n';\n    }\n    close(fd);\n    ljmm.buf_len = len;\n    return len;\n}\nstatic inline uintptr_t\npage_align_addr(uintptr_t addr) {\n    return (addr + ljmm.page_size - 1) & ~ljmm.page_mask;\n}\nstatic int\nparse_addr(const char* addr_str, uintptr_t *addr_val) {\n    uintptr_t addr = 0;\n    const char* p = addr_str;\n    while (1) {\n        char c = *p++;\n        if (c >= '0' && c <= '9') {\n            addr = addr * 16 + c - '0';\n            continue;\n        }\n        c |= 0x20;\n        if (c >= 'a' && c <= 'f') {\n            addr = addr * 16 + 10 + c - 'a';\n            continue;\n        }\n        *addr_val = addr;\n        return p - 1 - addr_str;\n    }\n    return 0;\n}\ntypedef struct {\n    uintptr_t start;\n    size_t size;\n} mem_blk_t;\nstatic uintptr_t\nfind_best_fit(size_t length) {\n    \n    if (read_maps_to_buffer() < 0) {\n        return 0;\n    }\n    length = page_align_addr(length);\n    mem_blk_t best_fit, prev_blk;\n    const char* buffer;\n    int ofst, buf_len;\n    uintptr_t upbound, lowbound;\n    lowbound = ljmm.addr_lowbound;\n    upbound = ljmm.addr_upbound;\n    best_fit.size = -1;\n    best_fit.start = upbound;\n    prev_blk.size = prev_blk.start = 0;\n    ofst = 0;\n    buffer = ljmm.buffer;\n    buf_len = ljmm.buf_len;\n    \n    ASSERT(buffer[buf_len-1] == '\\n');\n    while (ofst < buf_len) {\n        uintptr_t start_addr, end_addr;\n        \n        int advance = parse_addr(ljmm.buffer + ofst, &start_addr);\n        if (advance && (buffer[ofst + advance] == '-')) {\n            ofst += advance + 1;\n        } else {\n            \n            break;\n        }\n        \n        advance = parse_addr(buffer + ofst , &end_addr);\n        if (advance && buffer[ofst + advance] == ' ') {\n            ofst += advance + 1;\n            ASSERT(ofst < buf_len);\n            \n            while (buffer[ofst++] != '\\n') {}\n        } else {\n            \n            end_addr = upbound >= start_addr ? upbound : start_addr;\n        }\n        end_addr = page_align_addr(end_addr);\n        \n        uintptr_t hole_start = prev_blk.start + prev_blk.size;\n        uintptr_t hole_size = start_addr - hole_start;\n        if (hole_size >= length &&\n            (hole_start >= lowbound && (hole_start + length) <= upbound) &&\n            hole_size < best_fit.size) {\n            best_fit.start = hole_start;\n            best_fit.size = hole_size;\n            if (best_fit.size == length) {\n                break;\n            }\n        }\n        \n        if (unlikely(start_addr >= ADDR_1G)) {\n            \n            if (!ljmm.OS_take_care_1G_2G || start_addr >= upbound) {\n                break;\n            }\n        }\n        if (unlikely(end_addr >= upbound)) {\n            \n            break;\n        }\n        prev_blk.start = start_addr;\n        prev_blk.size = end_addr - start_addr;\n    }\n    return (best_fit.size != (uintptr_t)-1) ? best_fit.start : 0;\n}\nvoid *\nWRAP_MMAP(void *addr, size_t length, int prot, int flags, int fd,\n    off_t offset) {\n    if (!(flags & MAP_32BIT) || addr || !ljmm.init_succ) {\n        return REAL_MMAP(addr, length, prot, flags, fd, offset);\n    }\n    if (ljmm.OS_take_care_1G_2G) {\n        void *blk = REAL_MMAP(NULL, length, prot, flags, fd, offset);\n        if (blk != MAP_FAILED) {\n            return blk;\n        }\n    }\n    uintptr_t best_fit = find_best_fit(length);\n    if (best_fit) {\n        return REAL_MMAP((void*)best_fit, length, prot,\n                         flags & ~MAP_32BIT, fd, offset);\n    }\n    \n    return REAL_MMAP(NULL, length, prot, flags, fd, offset);\n}\nvoid\nljmm_let_OS_take_care_1G_2G(int turn_on) {\n    ljmm.OS_take_care_1G_2G = turn_on;\n}\nvoid\nljmm_test_set_test_param(const char* map_file, void *sbrk0, int page_size) {\n    ljmm.map_file = map_file;\n    ljmm.addr_lowbound = (uintptr_t)sbrk0;\n    \n    ASSERT(page_size && (((page_size - 1) & page_size) == 0));\n    ljmm.page_size = page_size;\n    ljmm.page_mask = page_size - 1;\n}\n", "rtext": "/// Initializes the ljmm system.\n///\n/// # Returns\n/// An integer status code.\npub fn ljmm_init() -> i32 {\n    unimplemented!()\n}\n/// Instructs the OS to take care of the [1G..2G] space.\n///\n/// # Parameters\n/// - `turn_on`: If non-zero, the OS should manage the space.\npub fn ljmm_let_os_take_care_1g_2g(turn_on: i32) {\n    unimplemented!()\n}\n/// Sets test parameters for the ljmm system.\n///\n/// # Parameters\n/// - `map_file`: The mapping file name.\n/// - `sbrk0`: An address representing the current program break (as a safe usize).\n/// - `page_size`: The system's page size.\npub fn ljmm_test_set_test_param(map_file: &str, sbrk0: usize, page_size: i32) {\n    unimplemented!()\n}"}
{"ctext": "// from header\n/*\n\ntypedef unsigned char\t\tuint8_t;\ntypedef unsigned int\t\tuint32_t;\ntypedef unsigned long long\tuint64_t;\ntypedef unsigned long\t\tsize_t;\n#define SIZE_MAX\t(~(size_t)0)\nvoid *memset(void *s, int c, size_t n);\nvoid *memcpy(void *dst, const void *src, size_t n);\nsize_t strlen(const char *s);\n\n*/\n#include \"std.h\"\nvoid *\nmemset(void *s, int c, size_t n)\n{\n\tsize_t i;\n\tfor (i=0; i<n; i++)\n\t\t((uint8_t *)s)[i] = (uint8_t)c;\n\treturn s;\n}\nvoid *\nmemcpy(void *dst, const void *src, size_t n)\n{\n\tsize_t i;\n\tfor (i=0; i<n; i++)\n\t\t((uint8_t *)dst)[i] = ((uint8_t *)src)[i];\n\treturn dst;\n}\nsize_t\nstrlen(const char *s)\n{\n\tsize_t i;\n\tfor (i=0; s[i]; i++) ;\n\treturn i;\n}\n", "rtext": "// Constants\npub const SIZE_MAX: usize = !0;\n// Function Declarations\npub fn memset(s: &mut [u8], c: i32, n: usize) -> &mut [u8] {\n    unimplemented!()\n}\npub fn memcpy<'a>(dst: &'a mut [u8], src: &'a [u8], n: usize) -> &'a mut [u8] {\n    unimplemented!()\n}\npub fn strlen(s: &str) -> usize {\n    unimplemented!()\n}"}
{"ctext": "// from header\n/*\n#define TOTP_EXPORT\t__attribute__((visibility(\"default\")))\nenum {\n\tTOTP_OK,\n\tTOTP_EBOUNDS\t\n};\nstatic inline void\nunpack32(uint32_t x, uint8_t a[4])\n{\n\ta[0] = (uint8_t)(x >> 24);\n\ta[1] = (uint8_t)(x >> 16);\n\ta[2] = (uint8_t)(x >> 8);\n\ta[3] = (uint8_t)x;\n}\nstatic inline void\nunpack64(uint64_t x, uint8_t a[8])\n{\n\tunpack32((uint32_t)(x >> 32), &a[0]);\n\tunpack32((uint32_t)x, &a[4]);\n}\nstatic inline uint32_t\npack32(const uint8_t a[4])\n{\n\treturn (a[0] << 24) | (a[1] << 16) | (a[2] << 8) | a[3];\n}\nstatic inline uint32_t\nrotl(uint32_t x, int n)\n{\n\treturn x << n | x >> (32-n);\n}\nTOTP_EXPORT int sha1(uint8_t *buf, size_t len, size_t cap,\n    uint8_t hash[20]);\nTOTP_EXPORT int hmac_sha1(const uint8_t key[64], const uint8_t *data,\n    size_t len, uint8_t hash[20]);\nTOTP_EXPORT int hotp(const uint8_t key[64], uint64_t counter);\nTOTP_EXPORT int totp(const uint8_t key[64], uint64_t time);\nTOTP_EXPORT size_t from_base32(const char *s, uint8_t *buf, size_t cap);\n\n*/\n#ifdef NO_STD\n# include \"std.h\"\n#else\n# include <stddef.h>\n# include <stdint.h>\n# include <string.h>\n#endif\n#include \"totp.h\"\nint\nsha1(uint8_t *buf, size_t len, size_t cap, uint8_t hash[20])\n{\n\t\n\tstatic const uint32_t k[] = { 0x5A827999, 0x6ED9EBA1,\n\t    0x8F1BBCDC, 0xCA62C1D6 };\n\tsize_t new_len, i,t;\t\t\n\tuint32_t h[5], w[80];\t\t\n\tuint32_t a,b,c,d,e, f, T;\t\n\t\n\t\n\tif (len > SIZE_MAX-9-63)\n\t\treturn TOTP_EBOUNDS;\n\tnew_len = (len+9+63)/64*64;\t\n\tif (new_len > cap)\n\t\treturn TOTP_EBOUNDS;\n\tmemset(buf+len, 0, new_len-len);\n\tbuf[len] = 1<<7;\n\tunpack64(len*8, &buf[new_len-8]);\n\t\n\th[0] = 0x67452301; h[1] = 0xEFCDAB89; h[2] = 0x98BADCFE;\n\th[3] = 0x10325476; h[4] = 0xC3D2E1F0;\n\t\n\tfor (i=0; i < new_len/64; i++) {\n\t\tfor (t=0; t<16; t++)\n\t\t\tw[t] = pack32(&buf[i*64 + t*4]);\n\t\tfor (; t<80; t++)\n\t\t\tw[t] = rotl(w[t-3]^w[t-8]^w[t-14]^w[t-16], 1);\n\t\ta=h[0]; b=h[1]; c=h[2]; d=h[3]; e=h[4];\n\t\tfor (t=0; t<80; t++) {\n\t\t\t\n\t\t\tf = t < 20 ? (b&c) ^ (~b&d) :\n\t\t\t    t < 40 ? b^c^d :\n\t\t\t    t < 60 ? (b&c) ^ (b&d) ^ (c&d) : b^c^d;\n\t\t\tT = rotl(a,5) + f + e + k[t/20] + w[t];\n\t\t\te = d; d = c; c = rotl(b,30);\n\t\t\tb = a; a = T;\n\t\t}\n\t\th[0] += a; h[1] += b; h[2] += c; h[3] += d; h[4] += e;\n\t}\n\tfor (i=0; i<5; i++)\n\t\tunpack32(h[i], &hash[i*4]);\n\treturn TOTP_OK;\n}\nint\nhmac_sha1(const uint8_t key[64], const uint8_t *data, size_t len,\n    uint8_t hash[20])\n{\n\tuint8_t buf[196];\n\tsize_t i;\n\tif (len > 64)\n\t\treturn TOTP_EBOUNDS;\n\tfor (i=0; i<64; i++) buf[i] = key[i] ^ 0x36;\n\tmemcpy(&buf[64], data, len);\n\tsha1(buf, 64+len, sizeof(buf), hash);\n\tfor (i=0; i<64; i++) buf[i] = key[i] ^ 0x5C;\n\tmemcpy(&buf[64], hash, 20);\n\tsha1(buf, 64+20, sizeof(buf), hash);\n\treturn TOTP_OK;\n}\nint\nhotp(const uint8_t key[64], uint64_t counter)\n{\n\tuint8_t data[8], hash[20];\n\tuint32_t trunc;\n\tunpack64(counter, data);\n\thmac_sha1(key, data, 8, hash);\n\ttrunc = pack32(&hash[hash[19] & 0xF]) & 0x7FFFFFFF;\n\treturn (int)(trunc % 1000000);\n}\nint\ntotp(const uint8_t key[64], uint64_t time)\n{\n\treturn hotp(key, time / 30);\n}\nsize_t\nfrom_base32(const char *s, uint8_t *buf, size_t cap)\n{\n\tsize_t i,j;\n\tuint8_t v[8];\n\tchar c;\n\tif (strlen(s) % 8)\n\t\treturn 0;\n\tif (cap < (strlen(s)+1)/8*5)\n\t\treturn 0;\n\tfor (i=0; s[i*8]; i++) {\n\t\tfor (j=0; j<8; j++)\n\t\t\tif ((c = s[i*8+j]) == '=') v[j] = 0;\n\t\t\telse if (c>='A' && c<='Z') v[j] = c-'A';\n\t\t\telse if (c>='a' && c<='z') v[j] = c-'a';\n\t\t\telse if (c>='2' && c<='7') v[j] = c-'2' + 26;\n\t\t\telse return 0;\n\t\tbuf[i*5]   = (v[0] << 3) | (v[1] >> 2);\n\t\tbuf[i*5+1] = (v[1] << 6) | (v[2] << 1) | (v[3] >> 4);\n\t\tbuf[i*5+2] = (v[3] << 4) | (v[4] >> 1);\n\t\tbuf[i*5+3] = (v[4] << 7) | (v[5] << 2) | (v[6] >> 3);\n\t\tbuf[i*5+4] = (v[6] << 5) | v[7];\n\t\tif (s[i*8+2] == '=') return i*5 + 1;\n\t\tif (s[i*8+4] == '=') return i*5 + 2;\n\t\tif (s[i*8+5] == '=') return i*5 + 3;\n\t\tif (s[i*8+7] == '=') return i*5 + 4;\n\t}\n\treturn i*5;\n}\n", "rtext": "// Importing required modules\nuse crate::std;\n// Constants\npub const TOTP_EXPORT: &str = \"__attribute__((visibility(\\\"default\\\")))\";\n// Function Declarations\npub fn hotp(key: &[u8; 64], counter: u64) -> i32 {\n    unimplemented!()\n}\npub fn sha1(buf: &mut [u8], len: usize, cap: usize, hash: &mut [u8; 20]) -> i32 {\n    unimplemented!()\n}\npub fn from_base32(s: &str, buf: &mut [u8], cap: usize) -> usize {\n    unimplemented!()\n}\npub fn unpack64(x: u64, a: &mut [u8; 8]) {\n    unimplemented!()\n}\npub fn pack32(a: &[u8; 4]) -> u32 {\n    unimplemented!()\n}\npub fn unpack32(x: u32, a: &mut [u8; 4]) {\n    unimplemented!()\n}\npub fn totp(key: &[u8; 64], time: u64) -> i32 {\n    unimplemented!()\n}\npub fn hmac_sha1(key: &[u8; 64], data: &[u8], len: usize, hash: &mut [u8; 20]) -> i32 {\n    unimplemented!()\n}\npub fn rotl(x: u32, n: i32) -> u32 {\n    unimplemented!()\n}"}
{"ctext": "// from header\n/*\n\n#ifndef _MVPTREE_H\n#define _MVPTREE_H\ntypedef enum mvp_datatype_t { \n    BYTEARRAY = 1, \n    UINT16ARRAY = 2, \n    UINT32ARRAY = 4, \n    UINT64ARRAY = 8 \n} MVPDataType;\ntypedef enum nodetype_t { \n    INTERNAL_NODE = 1, \n    LEAF_NODE \n} NodeType;\ntypedef enum mvp_error_t {\n    MVP_SUCCESS,            \n    MVP_ARGERR,             \n    MVP_NODISTANCEFUNC,     \n    MVP_MEMALLOC,           \n    MVP_NOLEAF,             \n    MVP_NOINTERNAL,         \n    MVP_PATHALLOC,          \n    MVP_VPNOSELECT,         \n    MVP_NOSV1RANGE,         \n    MVP_NOSV2RANGE,         \n    MVP_NOSPACE,            \n    MVP_NOSORT,             \n    MVP_FILEOPEN,           \n    MVP_FILECLOSE,          \n    MVP_MEMMAP,             \n    MVP_MUNMAP,             \n    MVP_NOWRITE,            \n    MVP_FILETRUNCATE,       \n    MVP_MREMAPFAIL,         \n    MVP_TYPEMISMATCH,       \n                            \n    MVP_KNEARESTCAP,        \n    MVP_EMPTYTREE,\n    MVP_NOSPLITS,           \n    MVP_BADDISTVAL,         \n    MVP_FILENOTFOUND,       \n    MVP_UNRECOGNIZED,       \n} MVPError;\ntypedef struct mvp_datapoint_t {\n    char *id;               \n    void *data;             \n    float *path;            \n    unsigned int datalen;       \n    MVPDataType type;       \n} MVPDP;\ntypedef float (*CmpFunc)(MVPDP *pointA, MVPDP *pointB);\ntypedef void (*MVPFreeFunc)(void *ptr);\ntypedef struct node_internal_t {\n    NodeType type;\n    MVPDP *sv1, *sv2;\n    float *M1, *M2;\n    void **child_nodes;\n} InternalNode;\ntypedef struct node_leaf_t {\n    NodeType type;\n    MVPDP *sv1, *sv2;\n    MVPDP **points;\n    float *d1, *d2;\n    unsigned int nbpoints;\n} LeafNode;\n   \ntypedef union node_t {\n    LeafNode leaf;\n    InternalNode internal;\n} Node;\ntypedef struct mvptree_t {\n    int branchfactor;      \n    int pathlength;        \n                           \n                           \n    int leafcap;           \n    int fd;                \n    int k;                 \n    MVPDataType datatype;    \n    off_t pos;             \n    off_t size;            \n    off_t pgsize;          \n    char *buf;             \n    Node *node;            \n    CmpFunc dist;          \n} MVPTree;\nMVPDP* dp_alloc(MVPDataType type);\nvoid dp_free(MVPDP *dp, MVPFreeFunc free_func);\nMVPTree* mvptree_alloc(MVPTree *tree,CmpFunc distance,\n                                       unsigned int bf,unsigned int p,unsigned int k);\nvoid mvptree_clear(MVPTree *tree, MVPFreeFunc free_func);\nMVPError mvptree_add(MVPTree *tree, MVPDP **points, unsigned int nbpoints);\nMVPDP** mvptree_retrieve(MVPTree *tree, MVPDP *target, unsigned int knearest, float radius,\n                                       unsigned int *nbresults, MVPError *error);\nMVPError mvptree_write(MVPTree *tree, const char *filename, int mode);\nMVPTree* mvptree_read(const char *filename, CmpFunc fnc, int branchfactor, int pathlength,\\\n                                                  int leafcapacity, MVPError *error);\nMVPError mvptree_print(FILE *stream, MVPTree *tree);\nconst char* mvp_errstr(MVPError err);\n#endif \n\n*/\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n#include <math.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include \"mvptree.h\"\n#define HEADER_SIZE 32\n#define _FILE_OFFSET_BITS 64\n#define _LARGEFILE64_SOURCE\nconst char *tag = \"phashmvp2010\";\nconst int version = 0x01000000;\nconst char *error_msgs[] = {\n    \"no error\",\n    \"bad argument\",\n    \"no distance function found\",\n    \"mem alloc error\",\n    \"no leaf node created\",\n    \"no internal node created\",\n    \"no path array alloc'd\",\n    \"could not select vantage points\",\n    \"could not calculate range from an sv1\",\n    \"could not calculate range from an sv2\",\n    \"points too compact\",\n    \"could not sort points\",\n    \"could not open file\",\n    \"could not close file\",\n    \"mmap error\",\n    \"unmap eror\",\n    \"no write\",\n    \"could not extend file\",\n    \"could not remap file\",\n    \"datatypes in conflict\",\n    \"no. retrieved exceeds k\",\n    \"empty tree\",\n    \"distance value either NaN or less than zero\",\n    \"could not open file\",\n    \"unrecognized node\" };\nconst char* mvp_errstr(MVPError err) {\n    return error_msgs[(int) err];\n}\nMVPDP* dp_alloc(MVPDataType type) {\n    MVPDP *newdp = (MVPDP*) malloc(sizeof(MVPDP));\n    newdp->id = NULL;\n    newdp->data = NULL;\n    newdp->datalen = 0;\n    newdp->type = type;\n    newdp->path = NULL;\n    return newdp;\n}\nvoid dp_free(MVPDP *dp, MVPFreeFunc free_func) {\n    if (dp) {\n        if (dp->path) { free(dp->path); }\n        if (free_func) {\n            if (dp->id)    free_func(dp->id);\n            if (dp->data) free_func(dp->data);\n        }\n        free(dp);\n    }\n}\nMVPTree* mvptree_alloc(MVPTree *tree, CmpFunc distance, unsigned int bf, unsigned int p,\n                                                           unsigned int k) {\n    if (distance == NULL) {\n        return NULL;\n    }\n    MVPTree *retTree;\n    if (tree == NULL) {\n        retTree = (MVPTree*) malloc(sizeof(MVPTree));\n        if (retTree  == NULL) { return NULL; }\n    } else {\n        retTree = tree;\n    }\n    retTree->branchfactor = bf;\n    retTree->pathlength   = p;\n    retTree->leafcap      = k;\n    retTree->dist         = distance;\n    retTree->datatype     = 0;\n    retTree->node         = NULL;\n    retTree->fd           = 0;\n    retTree->k            = 0;\n    retTree->size         = 0;\n    retTree->pos          = 0;\n    retTree->buf          = NULL;\n    retTree->pgsize       = sysconf(_SC_PAGESIZE);\n    return retTree;\n}\nstatic int is_nan(float x) {\n    float var = x;\n    return (var != var) ? 1 : 0;\n}\nstatic Node* create_leaf(unsigned int leafcap) {\n    Node *node = (Node*) malloc(sizeof(Node));\n    node->leaf.sv1 = NULL;\n    node->leaf.sv2 = NULL;\n    node->leaf.points = (MVPDP**) calloc(leafcap, sizeof(MVPDP*));\n    node->leaf.d1 = (float*) calloc(leafcap,sizeof(float));\n    node->leaf.d2 = (float*) calloc(leafcap,sizeof(float));\n    node->leaf.nbpoints = 0;\n    node->leaf.type = LEAF_NODE;\n    return node;\n}\nstatic Node* create_internal(unsigned int bf) {\n    Node *node = (Node*) malloc(sizeof(Node));\n    node->internal.sv1 = NULL;\n    node->internal.sv2 = NULL;\n    node->internal.M1 = (float*) calloc(bf-1, sizeof(float));\n    node->internal.M2 = (float*) calloc(bf, sizeof(float));\n    node->internal.child_nodes = calloc(bf*bf, sizeof(Node*));\n    node->internal.type = INTERNAL_NODE;\n    return node;\n}\nstatic void free_node(Node *node) {\n    if (node) {\n        if (node->leaf.type == LEAF_NODE) {\n            free(node->leaf.points);\n            free(node->leaf.d1);\n            free(node->leaf.d2);\n        } else if (node->internal.type == INTERNAL_NODE) {\n            free(node->internal.M1);\n            free(node->internal.M2);\n            free(node->internal.child_nodes);\n        }\n        free(node);\n    }\n}\nstatic void _mvptree_clear(MVPTree *tree, Node *node, MVPFreeFunc free_func, int lvl) {\n    if (!node) { return; }\n    int i;\n    if (node->internal.type == INTERNAL_NODE) {\n        int fanout = tree->branchfactor*tree->branchfactor;\n        for (i = 0; i < fanout; i++) {\n            _mvptree_clear(tree, node->internal.child_nodes[i], free_func, lvl+1);\n        }\n        dp_free(node->internal.sv1, free_func);\n        dp_free(node->internal.sv2, free_func);\n    } else {\n        dp_free(node->leaf.sv1, free_func);\n        dp_free(node->leaf.sv2, free_func);\n        for (i=0; i< node->leaf.nbpoints; i++) {\n            dp_free(node->leaf.points[i], free_func);\n        }\n    }\n    free_node(node);\n}\nvoid mvptree_clear(MVPTree *tree, MVPFreeFunc free_func) {\n    if (!tree || !tree->node) { return; }\n    _mvptree_clear(tree, tree->node, free_func, 0);\n}\nstatic int select_vantage_points(MVPDP **points, unsigned int nb,int *sv1_pos, int *sv2_pos,\n                                                      CmpFunc dist) {\n    if (!points || !sv1_pos || !sv2_pos || !dist || nb == 0) { return -1; }\n    *sv1_pos = (nb >= 1) ? 0 : -1;\n    *sv2_pos = -1;\n    float max_dist = 0.0f, d;\n    int i, j;\n    for (i = 0; i < nb; i++) {\n        for (j = i+1; j < nb; j++) {\n            d = dist(points[i], points[j]);\n            if (is_nan(d) || d < 0.0f) {\n                return -2;\n            }\n            if (d > max_dist) {\n                max_dist = d;\n                *sv1_pos = i;\n                *sv2_pos = j;\n            }\n        }\n    }\n    return 0;\n}\nstatic int find_splits(MVPDP **points, unsigned int nb, MVPDP *vp, MVPTree *tree,\n                                                     float *M, unsigned int lengthM) {\n    if (!points || nb == 0 || !M || lengthM == 0) return -1;\n    CmpFunc distfunc = tree->dist;\n    float *dist = (float*) malloc(nb*sizeof(float));\n    int i, j;\n    for (i = 0; i < nb; i++) {\n        dist[i] = distfunc(points[i], vp);\n        if (is_nan(dist[i]) || dist[i] < 0.0f) {\n            free(dist);\n            return -2;\n        }\n    }\n    int min_pos;\n    for (i = 0;i < nb-1;i++) {\n        min_pos = i;\n        for (j = i+1; j < nb; j++) {\n            if (dist[j] < dist[min_pos]) {\n                min_pos = j;\n            }\n        }\n        if (min_pos != i) {\n            float tmp = dist[min_pos];\n            dist[min_pos] = dist[i];\n            dist[i] = tmp;\n        }\n    }\n    for (i = 0; i < lengthM; i++) {\n        int index = (i+1)*nb/(lengthM+1);\n        if (index <= 0) { index = 0; }\n        if (index >= nb) { index = nb-1; }\n        M[i] = dist[index];\n    }\n    free(dist);\n    return 0;\n}\nstatic MVPDP*** sort_points(MVPDP **points, unsigned int nbpoints, int sv1_pos, int sv2_pos,\n                         MVPDP *vp, MVPTree *tree, int **counts, float *pivots) {\n    if (!points || !vp || !tree || !counts || !pivots || nbpoints == 0) { return NULL; }\n    CmpFunc distfunc = tree->dist;\n    int bf = tree->branchfactor;\n    int lengthM1 = bf-1;\n    MVPDP*** bins = (MVPDP***) malloc(bf*sizeof(MVPDP**));\n    if (!bins) return NULL;\n    *counts = (int*) calloc(bf, sizeof(int));\n    if (!counts) {\n        free(bins);\n        return NULL;\n    }\n    int i, k;\n    for (i=0; i < bf; i++) {\n        bins[i] = (MVPDP**) malloc(nbpoints*sizeof(MVPDP*));\n        if (!bins[i]) { return NULL; }\n    }\n    for (i=0;i<nbpoints;i++) {\n        if (i == sv1_pos || i == sv2_pos) { continue; }\n        float d = distfunc(vp, points[i]);\n        if (is_nan(d) || d < 0.0f) {\n            free(counts);\n            free(bins);\n            return NULL;\n        }\n        for (k = 0; k < lengthM1; k++) {\n            if (d <= pivots[k]) {\n                bins[k][(*counts)[k]] = points[i];\n                (*counts)[k]++;\n                break;\n            }\n        }\n        if (d > pivots[lengthM1-1]) {\n            bins[lengthM1][(*counts)[lengthM1]] = points[i];\n            (*counts)[lengthM1]++;\n        }\n    }\n    return bins;\n}\nstatic int find_distance_range_for_vp(MVPDP **points, unsigned int nbpoints, MVPDP *vp,\n                                      MVPTree *tree, int lvl) {\n    if (!points || nbpoints == 0 || !vp || !tree || !tree->dist) {\n        return -1;\n    }\n    CmpFunc func = tree->dist;\n    int i, error = 0;\n    for (i = 0; i < nbpoints; i++) {\n        float d = func(vp, points[i]);\n        if (is_nan(d) || d < 0.0f) {\n            return -2;\n        }\n        if (lvl < tree->pathlength) {\n            points[i]->path[lvl] = d;\n        }\n    }\n    return error;\n}\nstatic Node* _mvptree_add(MVPTree *tree, Node *node, MVPDP **points, unsigned int nbpoints,\n                                                               MVPError *error, int lvl) {\n    Node *new_node = node;\n    if (nbpoints == 0) { return new_node; }\n    if (!tree || lvl < 0 || !points) {\n        *error = MVP_ARGERR;\n        return NULL;\n    }\n    CmpFunc dist_fnc = tree->dist;\n    int bf = tree->branchfactor, lengthM1 = bf-1;\n    if (new_node == NULL) { \n        int sv1_pos, sv2_pos;\n        if (nbpoints <= tree->leafcap + 2) {\n            \n            new_node = create_leaf(tree->leafcap);\n            if (!new_node) {\n                *error = MVP_NOLEAF;\n                return NULL;\n            }\n            if (select_vantage_points(points, nbpoints, &sv1_pos, &sv2_pos, tree->dist) < 0) {\n                *error = MVP_VPNOSELECT;\n                free_node(new_node);\n                return NULL;\n            }\n            new_node->leaf.sv1 = (sv1_pos >= 0) ? points[sv1_pos] : NULL;\n            new_node->leaf.sv2 = (sv2_pos >= 0) ? points[sv2_pos] : NULL;\n            if (find_distance_range_for_vp(points, nbpoints, new_node->leaf.sv1,tree,lvl) < 0) {\n                *error = MVP_NOSV1RANGE;\n                free_node(new_node);\n                return NULL;\n            }\n            if (new_node->leaf.sv2) {\n                if (find_distance_range_for_vp(points,nbpoints,new_node->leaf.sv2,tree,lvl+1) < 0) {\n                    *error = MVP_NOSV2RANGE;\n                    free_node(new_node);\n                    return NULL;\n                }\n            }\n            \n            int i, count = 0;\n            for (i=0; i < nbpoints; i++) {\n                if (i == sv1_pos || i == sv2_pos) { continue; }\n                new_node->leaf.d1[count] = dist_fnc(points[i], new_node->leaf.sv1);\n                new_node->leaf.d2[count] = dist_fnc(points[i], new_node->leaf.sv2);\n                new_node->leaf.points[count++] = points[i];\n            }\n            new_node->leaf.nbpoints = count;\n        } else { \n            new_node = create_internal(tree->branchfactor);\n            if (!new_node) {\n                *error = MVP_NOINTERNAL;\n                return NULL;\n            }\n            if (select_vantage_points(points, nbpoints, &sv1_pos, &sv2_pos, tree->dist) < 0) {\n                *error = MVP_VPNOSELECT;\n                free_node(new_node);\n                return NULL;\n            }\n            new_node->internal.sv1 = points[sv1_pos];\n            new_node->internal.sv2 = points[sv2_pos];\n            if (find_distance_range_for_vp(points,nbpoints,new_node->internal.sv1,tree,lvl) < 0) {\n                *error = MVP_NOSV1RANGE;\n                free_node(new_node);\n                return NULL;\n            }\n            if (find_splits(points, nbpoints, new_node->internal.sv1, tree,\n                    new_node->internal.M1,lengthM1) < 0) {\n                *error = MVP_NOSPLITS;\n                free_node(new_node);\n                return NULL;\n            }\n            int i, j;\n            int *binlengths = NULL;\n            MVPDP ***bins = sort_points(points, nbpoints, sv1_pos, sv2_pos,\n                                     new_node->internal.sv1, tree, &binlengths, new_node->internal.M1);\n            if (!bins) {\n                *error = MVP_NOSORT;\n                free_node(new_node);\n                return NULL;\n            }\n            for (i=0; i < tree->branchfactor; i++) {\n                \n                if (find_distance_range_for_vp(bins[i], binlengths[i], new_node->internal.sv2,\n                                   tree, lvl+1) < 0) {\n                    *error = MVP_NOSV2RANGE;\n                    free_node(new_node);\n                    for (j=0; j < tree->branchfactor; j++) { free(bins[j]); }\n                    free(bins);\n                    return NULL;\n                }\n                if (find_splits(bins[i], binlengths[i], new_node->internal.sv2, tree,\n                        new_node->internal.M2 + i*lengthM1,lengthM1) < 0) {\n                    *error = MVP_NOSPLITS;\n                    free_node(new_node);\n                    for (j=0; j < tree->branchfactor; j++) { free(bins[j]); }\n                    free(bins);\n                    return NULL;\n                }\n                int *bin2lengths = NULL;\n                MVPDP ***bins2 = sort_points(bins[i], binlengths[i], -1, -1, new_node->internal.sv2,\n                                              tree, &bin2lengths, new_node->internal.M2 + i*lengthM1);\n                if (!bins2) {\n                    *error = MVP_NOSORT;\n                    for (j=0; j < tree->branchfactor; j++) { free(bins[j]); }\n                    free(bins);\n                    free_node(new_node);\n                    return NULL;\n                }\n                int j;\n                for (j=0; j < tree->branchfactor; j++) {\n                    \n                    Node *child = _mvptree_add(tree, NULL, bins2[j], bin2lengths[j], error, lvl+2);\n                    new_node->internal.child_nodes[i*tree->branchfactor+j] = child;\n                }\n                free(bin2lengths);\n                for (j = 0; j < tree->branchfactor; j++) { free(bins2[j]); }\n                free(bins2);\n            }\n            free(binlengths);\n            for (i=0; i < tree->branchfactor; i++) { free(bins[i]); }\n            free(bins);\n        }\n    } else { \n        if (new_node->leaf.type == LEAF_NODE) {\n            if (new_node->leaf.nbpoints + nbpoints <= tree->leafcap) {\n                \n                if (find_distance_range_for_vp(points,nbpoints,new_node->leaf.sv1,tree,lvl) < 0) {\n                    *error = MVP_NOSV1RANGE;\n                    return new_node;\n                }\n                int pos = 0;\n                if (new_node->leaf.sv2 == NULL) {\n                    new_node->leaf.sv2 = points[0];\n                    pos = 1;\n                }\n                if (find_distance_range_for_vp(points,nbpoints,new_node->leaf.sv2,tree,lvl+1) < 0) {\n                    *error = MVP_NOSV2RANGE;\n                    return new_node;\n                }\n                int count = new_node->leaf.nbpoints;\n                for (; pos < nbpoints;pos++) {\n                    new_node->leaf.d1[count] = tree->dist(points[pos], new_node->leaf.sv1);\n                    new_node->leaf.d2[count] = tree->dist(points[pos], new_node->leaf.sv2);\n                    new_node->leaf.points[count++] = points[pos];\n                }\n                new_node->leaf.nbpoints = count;\n            } else {\n                \n                unsigned int new_nb = new_node->leaf.nbpoints + nbpoints;\n                if (new_node->leaf.sv1) { new_nb++; }\n                if (new_node->leaf.sv2) { new_nb++; }\n                MVPDP **tmp_pts = (MVPDP**) malloc(new_nb*sizeof(MVPDP*));\n                if (!tmp_pts) {\n                    *error = MVP_MEMALLOC;\n                    return new_node;\n                }\n                int i, index = 0;\n                if (new_node->leaf.sv1) { tmp_pts[index++] = new_node->leaf.sv1; }\n                if (new_node->leaf.sv2) { tmp_pts[index++] = new_node->leaf.sv2; }\n                for (i=0; i < new_node->leaf.nbpoints; i++) {\n                    tmp_pts[index++] = new_node->leaf.points[i];\n                }\n                for (i=0; i < nbpoints; i++) {\n                    tmp_pts[index++] = points[i];\n                }\n                Node *old_node = new_node;\n                free_node(old_node);\n                new_node = _mvptree_add(tree, NULL, tmp_pts, new_nb, error, lvl);\n                free(tmp_pts);\n            }\n        } else { \n            if (find_distance_range_for_vp(points, nbpoints, new_node->internal.sv1,tree,lvl) < 0) {\n                *error = MVP_NOSV1RANGE;\n                return new_node;\n            }\n            int *binlengths = NULL;\n            MVPDP ***bins = sort_points(points, nbpoints, -1, -1, new_node->internal.sv1,\n                                                      tree, &binlengths, new_node->internal.M1);\n            int i;\n            if (!bins) {\n                *error = MVP_NOSORT;\n                return new_node;\n            }\n            for (i=0; i < tree->branchfactor; i++) {\n                \n                if (binlengths[i] <= 0) {\n                    continue;\n                }\n                int j;\n                if (find_distance_range_for_vp(bins[i], binlengths[i],\n                                                new_node->internal.sv2, tree, lvl+1) < 0) {\n                    *error = MVP_NOSV2RANGE;\n                    for (j=0; j < tree->branchfactor; j++) { free(bins[j]); }\n                    free(bins);\n                    return new_node;\n                }\n                int *bin2lengths = NULL;\n                MVPDP ***bins2 = sort_points(bins[i], binlengths[i], -1, -1,new_node->internal.sv2,\\\n                           tree, &bin2lengths, new_node->internal.M2 + i*lengthM1);\n                if (!bins2) {\n                    *error = MVP_NOSORT;\n                    for (j=0; j < tree->branchfactor; j++) { free(bins[j]); }\n                    free(bins);\n                    return new_node;\n                }\n                for (j=0; j < tree->branchfactor; j++) {\n                    \n                    \n                    Node *child;\n                    child = _mvptree_add(tree,\n                                          new_node->internal.child_nodes[i*tree->branchfactor + j],\n                                          bins2[j],  bin2lengths[j],error, lvl+2);\n                    new_node->internal.child_nodes[i*tree->branchfactor+j] = child;\n                    if (*error != MVP_SUCCESS) { break; }\n                }\n                free(bin2lengths);\n                for (j=0; j <tree->branchfactor;j++) { free(bins2[j]); }\n                free(bins2);\n            }\n            free(binlengths);\n            for (i=0;i<tree->branchfactor;i++) { free(bins[i]); }\n            free(bins);\n        }\n    }\n    return new_node;\n}\nMVPError mvptree_add(MVPTree *tree, MVPDP **points, unsigned int nbpoints) {\n    MVPError err = MVP_SUCCESS;\n    if (nbpoints == 0) { return err; }\n    if (tree && points) {\n        if (tree->datatype == 0) {\n            tree->datatype = points[0]->type;\n        }\n        if (tree->datatype != points[0]->type) {\n            return MVP_TYPEMISMATCH;\n        }\n        unsigned int i;\n        for (i=0; i < nbpoints; i++) {\n            points[i]->path = (float*) malloc(tree->pathlength*sizeof(float));\n            if (points[i]->path == NULL) {\n                return MVP_PATHALLOC;\n            }\n            memset(points[i]->path, 0, tree->pathlength*sizeof(float));\n        }\n        tree->node = _mvptree_add(tree, tree->node, points, nbpoints, &err, 0);\n    } else {\n        err = MVP_ARGERR;\n    }\n    return err;\n}\nstatic\nMVPError _mvptree_retrieve(MVPTree *tree,Node *node,MVPDP *target, float radius, MVPDP** results,\n                                                          unsigned int *nbresults, int lvl) {\n    MVPError err = MVP_SUCCESS;\n    int bf = tree->branchfactor;\n    int lengthM1 = bf - 1;\n    float d1, d2;\n    if (node == NULL) return err;\n    CmpFunc distance = tree->dist;\n    unsigned int i, j;\n    if (node->leaf.type == LEAF_NODE) {\n        d1 = distance(target, node->leaf.sv1);\n        if (is_nan(d1) || d1 < 0.0f) {\n            return MVP_BADDISTVAL;\n        }\n        if (lvl < tree->pathlength) { target->path[lvl] = d1; }\n        if (d1 <= radius) {\n            results[(*nbresults)++] = node->leaf.sv1;\n            if (*nbresults >= tree->k) { return MVP_KNEARESTCAP; }\n        }\n        if (tree->node->leaf.sv2) {\n            d2 = distance(target, node->leaf.sv2);\n            if (is_nan(d2) || d2 < 0.0f) {\n                return MVP_BADDISTVAL;\n            }\n            if (d2 <= radius) {\n                results[(*nbresults)++] = node->leaf.sv2;\n                if (*nbresults >= tree->k) { return MVP_KNEARESTCAP; }\n            }\n            if (lvl+1 < tree->pathlength) { target->path[lvl+1] = d2; }\n            for (i=0; i < node->leaf.nbpoints; i++) {\n                \n                \n                if (d1 - radius <= node->leaf.d1[i] && d1 + radius >= node->leaf.d1[i]) {\n                    if (d2 - radius <= node->leaf.d2[i] && d2 + radius >= node->leaf.d2[i]) {\n                        int endpath = (lvl+1 < tree->pathlength) ? lvl+1 : tree->pathlength;\n                        int skip = 0;\n                        for (j=0; j < endpath; j++) {\n                            if (target->path[j] - radius <= node->leaf.points[i]->path[j] &&\n                                target->path[j] + radius >= node->leaf.points[i]->path[j]) {\n                                continue;\n                            } else {\n                                skip = 1;\n                                break;\n                            }\n                        }\n                        if (!skip) {\n                            float d = distance(target, node->leaf.points[i]);\n                            if (is_nan(d) || d < 0.0) {\n                                return MVP_BADDISTVAL;\n                            }\n                            if (d <= radius) {\n                                results[(*nbresults)++] = node->leaf.points[i];\n                                if (*nbresults >= tree->k) {\n                                    return MVP_KNEARESTCAP;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    } else if (node->internal.type == INTERNAL_NODE) {\n        d1 = distance(target, node->internal.sv1);\n        if (is_nan(d1) || d1 < 0.0f) {\n            return MVP_BADDISTVAL;\n        }\n        if (d1 <= radius) {\n            results[(*nbresults)++] = node->internal.sv1;\n            if (*nbresults >= tree->k) return MVP_KNEARESTCAP;\n        }\n        if (lvl < tree->pathlength) target->path[lvl] = d1;\n        d2 = distance(target, node->internal.sv2);\n        if (is_nan(d2) || d2 < 0.0f) {\n            return MVP_BADDISTVAL;\n        }\n        if (d2 <= radius) {\n            results[(*nbresults)++] = node->internal.sv2;\n            if (*nbresults >= tree->k) { return MVP_KNEARESTCAP; }\n        }\n        if (lvl+1 < tree->pathlength) { target->path[lvl+1] = d2; }\n        \n        for (i=0; i < lengthM1; i++) {\n            if (d1 - radius <= node->internal.M1[i]) {\n                \n                for (j=0; j < lengthM1; j++) {\n                    if (d2 - radius <= node->internal.M2[i*lengthM1+j]) {\n                        err = _mvptree_retrieve(tree,node->internal.child_nodes[i*bf+j],target,\n                                                                        radius, results, nbresults, lvl+2);\n                        if (err != MVP_SUCCESS) { return err; }\n                    }\n                }\n                \n                if (d2 + radius >= node->internal.M2[i*lengthM1+lengthM1-1]) {\n                    err = _mvptree_retrieve(tree,node->internal.child_nodes[i*bf+lengthM1],\n                                                target, radius, results, nbresults, lvl+2);\n                    if (err != MVP_SUCCESS) { return err; }\n                }\n            }\n        }\n        \n        if (d1 + radius >= node->internal.M1[lengthM1-1]) {\n            \n            for (j=0; j < lengthM1; j++) {\n                if (d2 - radius <= node->internal.M2[lengthM1*lengthM1+j]) {\n                    err = _mvptree_retrieve(tree,node->internal.child_nodes[bf*lengthM1+j],\n                                                    target, radius, results, nbresults, lvl+2);\n                    if (err != MVP_SUCCESS) { return err; }\n                }\n            }\n            \n            if (d2 + radius >= node->internal.M2[lengthM1*lengthM1+lengthM1-1]) {\n                err = _mvptree_retrieve(tree,node->internal.child_nodes[bf*lengthM1+lengthM1],\n                                                 target, radius, results, nbresults, lvl+2);\n                if (err != MVP_SUCCESS) { return err; }\n            }\n        }\n    } else {\n        err = MVP_UNRECOGNIZED;\n    }\n    return err;\n}\nMVPDP** mvptree_retrieve(MVPTree *tree, MVPDP *target, unsigned int knearest, float radius,\n                                                 unsigned int *nbresults,MVPError *error) {\n    if (!tree || !target || !nbresults || knearest == 0 || radius < 0) {\n        *error = MVP_ARGERR;\n        return NULL;\n    }\n    if (!tree->dist) {\n        *error = MVP_NODISTANCEFUNC;\n        return NULL;\n    }\n    *nbresults = 0;\n    *error = MVP_SUCCESS;\n    if (!tree->node) {\n        *error = MVP_EMPTYTREE;\n        return NULL;\n    }\n    MVPDP **results = (MVPDP**) malloc(knearest*sizeof(MVPDP*));\n    if (!results) {\n        *error = MVP_MEMALLOC;\n        return NULL;\n    }\n    target->path = (float*) malloc(tree->pathlength*sizeof(float));\n    if (target->path == NULL) {\n        *error = MVP_MEMALLOC;\n        free(results);\n        return NULL;\n    }\n    tree->k = knearest;\n    *error = _mvptree_retrieve(tree, tree->node, target, radius, results, nbresults, 0);\n    free(target->path);\n    target->path = NULL;\n    return results;\n}\nstatic off_t write_datapoint(MVPDP *dp, MVPTree *tree) {\n    off_t start = tree->pos;\n    off_t pos = tree->pos;\n    uint8_t active = 0;\n    uint32_t bytelength = 0;\n    char *buf = tree->buf;\n    if (dp == NULL) {\n        memcpy(&buf[pos++], &active, 1);\n        memcpy(&buf[pos], &bytelength, sizeof(uint32_t));\n        pos += sizeof(uint32_t);\n        tree->pos = pos;\n        return start;\n    }\n    active = 1;\n    uint8_t idlen = strlen(dp->id);\n    uint32_t datalength = dp->datalen;\n    uint8_t type = dp->type;\n    bytelength = sizeof(uint8_t) + idlen + sizeof(uint32_t) +\n                            datalength*type + (tree->pathlength)*sizeof(float);\n    memcpy(&buf[pos++], &active    , 1);\n    memcpy(&buf[pos]  , &bytelength, sizeof(uint32_t));\n    pos += sizeof(uint32_t);\n    memcpy(&buf[pos++], &idlen     , 1);\n    memcpy(&buf[pos]  , dp->id     , idlen);\n    pos += idlen;\n    memcpy(&buf[pos]  , &datalength, sizeof(uint32_t));\n    pos += sizeof(uint32_t);\n    memcpy(&buf[pos]  , dp->data   , datalength*type);\n    pos += datalength*type;\n    memcpy(&buf[pos]  , dp->path   , (tree->pathlength)*sizeof(float));\n    pos += (tree->pathlength)*sizeof(float);\n    tree->pos = pos;\n    return start;\n}\nstatic int extend_mvpfile(MVPTree *tree) {\n    if (munmap(tree->buf, tree->size) < 0) {\n        return -1;\n    }\n    if (ftruncate(tree->fd, tree->size + tree->pgsize) < 0) {\n        return -2;\n    }\n    tree->size += tree->pgsize;\n    char *buf = (char*) mmap(NULL, tree->size, PROT_READ|PROT_WRITE, MAP_SHARED, tree->fd, 0);\n    if (buf == NULL) {\n        return -3;\n    }\n    tree->buf = buf;\n    return 0;\n}\nstatic off_t _mvptree_write(MVPTree *tree,Node *node,MVPError *error,int lvl) {\n    off_t start_pos = tree->pos;\n    if (node == NULL) { return 0; }\n    uint8_t node_type = (uint8_t) node->leaf.type;\n    if (node->leaf.type == LEAF_NODE) {\n        uint32_t nbpoints = node->leaf.nbpoints;\n        if (tree->pos >= tree->size - tree->pgsize/2) {\n            if (extend_mvpfile(tree) < 0) {\n                *error = MVP_FILETRUNCATE;\n                return start_pos;\n            }\n        }\n        \n        memcpy(&tree->buf[tree->pos++], &node_type, 1);\n        write_datapoint(node->leaf.sv1, tree);\n        write_datapoint(node->leaf.sv2, tree);\n        memcpy(&tree->buf[tree->pos], &nbpoints, sizeof(uint32_t));\n        tree->pos += sizeof(uint32_t);\n        \n        int i;\n        off_t saved_pos = tree->pos;\n        tree->pos += (tree->leafcap)*(2*sizeof(float)+sizeof(off_t));\n        for (i=0; i < nbpoints; i++) {\n            if (tree->pos >= tree->size - tree->pgsize/2) {\n                if (extend_mvpfile(tree) < 0) {\n                    *error = MVP_FILETRUNCATE;\n                    break;\n                }\n            }\n            memcpy(&tree->buf[saved_pos], &(node->leaf.d1[i]), sizeof(float));\n            saved_pos += sizeof(float);\n            memcpy(&tree->buf[saved_pos], &(node->leaf.d2[i]), sizeof(float));\n            saved_pos += sizeof(float);\n            off_t offset = write_datapoint(node->leaf.points[i], tree);\n            memcpy(&tree->buf[saved_pos], &offset, sizeof(off_t));\n            saved_pos += sizeof(off_t);\n        }\n    } else if (node->internal.type == INTERNAL_NODE) {\n        const uint8_t fileno = 0;\n        int bf = tree->branchfactor;\n        int lengthM1 = bf - 1;\n        int lengthM2 = (bf - 1)*bf;\n        int fanout   = bf*bf;\n        memcpy(&tree->buf[tree->pos++], &node_type, 1);\n        write_datapoint(node->internal.sv1, tree);\n        write_datapoint(node->internal.sv2, tree);\n        memcpy(&tree->buf[tree->pos], node->internal.M1, lengthM1*sizeof(float));\n        tree->pos += lengthM1*sizeof(float);\n        memcpy(&tree->buf[tree->pos], node->internal.M2, lengthM2*sizeof(float));\n        tree->pos += lengthM2*sizeof(float);\n        off_t saved_pos = tree->pos;\n        tree->pos += fanout*(sizeof(uint8_t) + sizeof(off_t));\n        int i;\n        for (i=0; i < fanout; i++) {\n            if (tree->pos >= tree->size - tree->pgsize/2) {\n                if (extend_mvpfile(tree) < 0) {\n                    *error = MVP_FILETRUNCATE;\n                    break;\n                }\n            }\n            off_t offset = _mvptree_write(tree, node->internal.child_nodes[i], error, lvl+2);\n            memcpy(&tree->buf[saved_pos++], &fileno, 1);\n            memcpy(&tree->buf[saved_pos]  , &offset, sizeof(off_t));\n            saved_pos += sizeof(off_t);\n        }\n    } else {\n        *error = MVP_UNRECOGNIZED;\n    }\n    \n    return start_pos;\n}\nMVPError mvptree_write(MVPTree *tree, const char *filename, int mode) {\n    if (!tree || !tree->dist || !tree->node || !filename) {\n        return MVP_ARGERR;\n    }\n    tree->fd = open(filename, O_CREAT|O_RDWR|O_TRUNC, mode);\n    if (tree->fd < 0) {\n        return MVP_FILEOPEN;\n    }\n    tree->pgsize = sysconf(_SC_PAGESIZE);\n    if (ftruncate(tree->fd, tree->pgsize) < 0) {\n        close(tree->fd);\n        return MVP_FILETRUNCATE;\n    }\n    tree->size = tree->pgsize;\n    char *buf  = (char*) mmap(NULL, tree->size, PROT_READ|PROT_WRITE, MAP_SHARED, tree->fd, 0);\n    if (buf == NULL) {\n        close(tree->fd);\n        return MVP_MEMMAP;\n    }\n    off_t pos = 0;\n    uint8_t bf = tree->branchfactor;\n    uint8_t pl = tree->pathlength;\n    uint8_t lc = tree->leafcap;\n    uint8_t ht = (uint8_t) tree->node->internal.sv1->type;\n    \n    memcpy(&buf[pos], tag, strlen(tag)+1);\n    pos += strlen(tag)+1;\n    memcpy(&buf[pos], &version, sizeof(version));\n    pos += sizeof(version);\n    memcpy(&buf[pos++], &bf, 1);\n    memcpy(&buf[pos++], &pl, 1);\n    memcpy(&buf[pos++], &lc, 1);\n    memcpy(&buf[pos++], &ht, 1);\n    tree->buf = buf;\n    pos = HEADER_SIZE;\n    tree->pos = pos;\n    \n    MVPError error = MVP_SUCCESS;\n    _mvptree_write(tree, tree->node, &error, 0);\n    \n    if (msync(tree->buf, tree->size, MS_SYNC) < 0) {\n        error = MVP_MEMMAP;\n    }\n    if (munmap(tree->buf, tree->size) < 0) {\n        error = MVP_MUNMAP;\n    }\n    tree->buf = NULL;\n    if (close(tree->fd) < 0) {\n        error = MVP_FILECLOSE;\n    }\n    return error;\n}\nstatic MVPDP* read_datapoint(MVPTree *tree) {\n    uint8_t active, idlen;\n    uint32_t bytelength, datalength;\n    memcpy(&active, &tree->buf[tree->pos], sizeof(active));\n    tree->pos += sizeof(active);\n    memcpy(&bytelength, &tree->buf[tree->pos], sizeof(bytelength));\n    tree->pos += sizeof(bytelength);\n    if (active == 0 && bytelength == 0) return NULL;\n    MVPDP *dp = dp_alloc(tree->datatype);\n    if (!dp) { return NULL; }\n    dp->path = (float*) malloc(tree->pathlength*sizeof(float));\n    if (!dp->path) { return NULL; }\n    memcpy(&idlen, &tree->buf[tree->pos], sizeof(uint8_t));\n    tree->pos += sizeof(uint8_t);\n    dp->id = malloc(idlen+1);\n    memcpy(dp->id, &tree->buf[tree->pos], idlen);\n    tree->pos += idlen;\n    dp->id[idlen] = '\\0';\n    memcpy(&datalength, &tree->buf[tree->pos], sizeof(uint32_t));\n    tree->pos += sizeof(uint32_t);\n    dp->datalen = datalength;\n    dp->data = malloc(datalength*tree->datatype);\n    memcpy(dp->data, &tree->buf[tree->pos], datalength*tree->datatype);\n    tree->pos += datalength*tree->datatype;\n    memcpy(dp->path, &tree->buf[tree->pos], tree->pathlength*sizeof(float));\n    tree->pos += tree->pathlength*sizeof(float);\n    return dp;\n}\nstatic Node* _mvptree_read_node(MVPTree *tree, MVPError *error, int lvl) {\n    uint8_t node_type;\n    Node *node = NULL;\n    memcpy(&node_type, &tree->buf[tree->pos++], sizeof(uint8_t));\n    if (node_type == LEAF_NODE) {\n        uint32_t nbpoints;\n        node = create_leaf(tree->leafcap);\n        if (!node) {\n            *error = MVP_NOLEAF;\n            return node;\n        }\n        node->leaf.sv1 = read_datapoint(tree);\n        node->leaf.sv2 = read_datapoint(tree);\n        memcpy(&nbpoints,&tree->buf[tree->pos], sizeof(uint32_t));\n        tree->pos += sizeof(uint32_t);\n        node->leaf.nbpoints = nbpoints;\n        off_t saved_pos = tree->pos;\n        int i;\n        off_t offset;\n        for (i = 0; i < nbpoints; i++) {\n            memcpy(&(node->leaf.d1[i]), &tree->buf[saved_pos], sizeof(float));\n            saved_pos += sizeof(float);\n            memcpy(&(node->leaf.d2[i]), &tree->buf[saved_pos], sizeof(float));\n            saved_pos += sizeof(float);\n            memcpy(&offset, &tree->buf[saved_pos], sizeof(off_t));\n            saved_pos += sizeof(off_t);\n            tree->pos = offset;\n            node->leaf.points[i] = read_datapoint(tree);\n        }\n    } else if (node_type == INTERNAL_NODE) {\n        int bf = tree->branchfactor;\n        int lengthM1 = bf - 1;\n        int lengthM2 = (bf - 1)*bf;\n        int fanout   = bf*bf;\n        uint8_t fileno;\n        node = create_internal(bf);\n        if (node == NULL) {\n            *error = MVP_NOINTERNAL;\n            return node;\n        }\n        node->internal.sv1 = read_datapoint(tree);\n        node->internal.sv2 = read_datapoint(tree);\n        memcpy(node->internal.M1, &tree->buf[tree->pos], lengthM1*sizeof(float));\n        tree->pos += lengthM1*sizeof(float);\n        memcpy(node->internal.M2, &tree->buf[tree->pos], lengthM2*sizeof(float));\n        tree->pos += lengthM2*sizeof(float);\n        int i;\n        off_t offset, saved_pos = tree->pos;\n        for (i = 0;i < fanout; i++) {\n            memcpy(&fileno, &tree->buf[saved_pos], sizeof(fileno));\n            saved_pos += sizeof(fileno);\n            memcpy(&offset, &tree->buf[saved_pos], sizeof(offset));\n            saved_pos += sizeof(offset);\n            tree->pos = offset;\n            node->internal.child_nodes[i] = _mvptree_read_node(tree, error, lvl+2);\n            if (*error != MVP_SUCCESS) { break; }\n        }\n    } else {\n        *error = MVP_UNRECOGNIZED;\n    }\n    return node;\n}\nMVPTree* mvptree_read(const char *filename, CmpFunc fnc, int branchfactor, int pathlength,\n                               int leafcapacity,MVPError *error) {\n    if (!error) { return NULL; }\n    *error = MVP_SUCCESS;\n    if (!filename || !fnc) {\n        *error = MVP_ARGERR;\n        return NULL;\n    }\n    MVPTree *tree = NULL;\n    int fd = open(filename, O_RDONLY);\n    if (fd < 0) {\n        \n        tree = mvptree_alloc(NULL, fnc, branchfactor, pathlength, leafcapacity);\n        *error = MVP_FILENOTFOUND;\n        return tree;\n    }\n    struct stat file_info;\n    if (fstat(fd, &file_info) < 0) {\n        *error = MVP_FILEOPEN;\n        return NULL;\n    }\n    off_t size = file_info.st_size;\n    char *buf = (char*) mmap(NULL, size, PROT_READ, MAP_SHARED, fd, 0);\n    if (buf == NULL) {\n        *error = MVP_MEMMAP;\n        close(fd);\n        return NULL;\n    }\n    off_t pos = 0;\n    char line[16];\n    int v;\n    uint8_t bf, pl, lc, ht;\n    memcpy(line, &buf[pos], strlen(tag)+1);\n    pos += strlen(tag)+1;\n    memcpy(&v, &buf[pos], sizeof(int));\n    pos += sizeof(int);\n    memcpy(&bf, &buf[pos++], 1);\n    memcpy(&pl, &buf[pos++], 1);\n    memcpy(&lc, &buf[pos++], 1);\n    memcpy(&ht, &buf[pos++], 1);\n    tree = mvptree_alloc(NULL, fnc, bf, pl, lc);\n    if (!tree) {\n        *error = MVP_MEMALLOC;\n        return NULL;\n    }\n    tree->pgsize = sysconf(_SC_PAGESIZE);\n    tree->size = size;\n    tree->buf = buf;\n    tree->pos = HEADER_SIZE;\n    tree->fd = fd;\n    tree->datatype = (MVPDataType) ht;\n    tree->dist = fnc;\n    tree->node = _mvptree_read_node(tree, error, 0);\n    if (munmap(buf, size) < 0) {\n        *error = MVP_MUNMAP;\n    }\n    tree->buf = NULL;\n    if (close(fd) < 0) {\n        *error = MVP_FILECLOSE;\n    }\n    tree->buf = NULL;\n    tree->pos = 0;\n    tree->fd  = 0;\n    return tree;\n}\nstatic MVPError _mvptree_print(FILE *stream, MVPTree *tree, Node *node, int lvl) {\n    MVPError error = MVP_SUCCESS;\n    Node *next_node = node;\n    int bf = tree->branchfactor, lengthM1 = bf-1, lengthM2 = bf, fanout = bf*bf;\n    if (next_node) {\n        if (next_node->leaf.type == LEAF_NODE) {\n            fprintf(stream, \"LEAF%d  (%d points)\\n\", lvl, next_node->leaf.nbpoints);\n            if (next_node->leaf.sv1) {\n                fprintf(stream, \"    sv1: %s\\n\", next_node->leaf.sv1->id);\n            }\n            if (next_node->leaf.sv2) {\n                fprintf(stream, \"    sv2: %s\\n\", next_node->leaf.sv2->id);\n            }\n            int i;\n            for (i = 0; i < next_node->leaf.nbpoints; i++) {\n                fprintf(stream, \"        point[%d]: %s\\n\", i, next_node->leaf.points[i]->id);\n            }\n        } else if (next_node->internal.type == INTERNAL_NODE) {\n            fprintf(stream, \"INTERNAL%d\\n\", lvl);\n            fprintf(stream, \"  sv1: %s\\n\", next_node->internal.sv1->id);\n            fprintf(stream, \"  sv2: %s\\n\", next_node->internal.sv2->id);\n            int i;\n            for (i=0; i < lengthM1; i++) {\n                fprintf(stream, \"  M1[%d] = %.4f;\", i, next_node->internal.M1[i]);\n            }\n            for (i=0; i < lengthM2; i++) {\n                fprintf(stream, \"  M2[%d] = %.4f;\", i, next_node->internal.M2[i]);\n            }\n            fprintf(stream, \"\\n\");\n            for (i=0; i < fanout; i++) {\n                error = _mvptree_print(stream, tree, node->internal.child_nodes[i], lvl+2);\n                if (error != MVP_SUCCESS) { break; }\n            }\n        } else {\n            error = MVP_UNRECOGNIZED;\n        }\n    } else {\n        fprintf(stream, \"NULL%d\\n\", lvl);\n    }\n    return error;\n}\nMVPError mvptree_print(FILE *stream, MVPTree *tree) {\n    if (stream == NULL || tree == NULL) {\n        return MVP_ARGERR;\n    }\n    MVPError err = _mvptree_print(stream, tree, tree->node, 0);\n    if (err != MVP_SUCCESS) {\n        fprintf(stream, \"malformed tree: %s\\n\", mvp_errstr(err));\n    }\n    return err;\n}\n", "rtext": "use std::fs::File;\nuse std::io::{self, Write};\nuse std::ptr;\nuse std::os::raw::c_int;\nuse std::sync::Arc;\nuse std::rc::Rc;\nuse std::cell::RefCell;\npub const TAG: &str = \"phashmvp2010\";\npub const VERSION: u32 = 0x01000000;\npub const HEADER_SIZE: usize = 32;\npub const FILE_OFFSET_BITS: usize = 64;\npub const ERROR_MSGS: [&str; 25] = [\n    \"no error\",\n    \"bad argument\",\n    \"no distance function found\",\n    \"mem alloc error\",\n    \"no leaf node created\",\n    \"no internal node created\",\n    \"no path array alloc'd\",\n    \"could not select vantage points\",\n    \"could not calculate range from an sv1\",\n    \"could not calculate range from an sv2\",\n    \"points too compact\",\n    \"could not sort points\",\n    \"could not open file\",\n    \"could not close file\",\n    \"mmap error\",\n    \"unmap error\",\n    \"no write\",\n    \"could not extend file\",\n    \"could not remap file\",\n    \"datatypes in conflict\",\n    \"no. retrieved exceeds k\",\n    \"empty tree\",\n    \"distance value either NaN or less than zero\",\n    \"could not open file\",\n    \"unrecognized node\",\n];\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum MVPDataType {\n    ByteArray = 1,\n    UInt16Array = 2,\n    UInt32Array = 4,\n    UInt64Array = 8,\n}\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum NodeType {\n    InternalNode = 1,\n    LeafNode,\n}\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum MVPError {\n    Success,\n    ArgErr,\n    NoDistanceFunc,\n    MemAlloc,\n    NoLeaf,\n    NoInternal,\n    PathAlloc,\n    VpNoSelect,\n    NoSv1Range,\n    NoSv2Range,\n    NoSpace,\n    NoSort,\n    FileOpen,\n    FileClose,\n    MemMap,\n    Munmap,\n    NoWrite,\n    FileTruncate,\n    MremapFail,\n    TypeMismatch,\n    KNearestCap,\n    EmptyTree,\n    NoSplits,\n    BadDistVal,\n    FileNotFound,\n    Unrecognized,\n}\n#[derive(Debug, Clone)]\npub struct MVPDatapoint {\n    pub id: String,\n    pub data: Vec<u8>,\n    pub path: Vec<f32>,\n    pub datalen: usize,\n    pub data_type: MVPDataType,\n}\npub type DistanceFunction = fn(&MVPDatapoint, &MVPDatapoint) -> f32;\npub struct InternalNode {\n    pub node_type: NodeType,\n    pub sv1: Option<Arc<MVPDatapoint>>,\n    pub sv2: Option<Arc<MVPDatapoint>>,\n    pub m1: Vec<f32>,\n    pub m2: Vec<f32>,\n    pub child_nodes: Vec<Rc<RefCell<Node>>>,\n}\nimpl InternalNode{\n    pub fn new(bf:u32) -> Self {\n       unimplemented!() \n    }\n}\npub struct LeafNode {\n    pub node_type: NodeType,\n    pub sv1: Option<Arc<MVPDatapoint>>,\n    pub sv2: Option<Arc<MVPDatapoint>>,\n    pub points: Vec<Arc<MVPDatapoint>>,\n    pub d1: Vec<f32>,\n    pub d2: Vec<f32>,\n    pub nbpoints: usize,\n}\nimpl LeafNode {\n    pub fn new(bf:u32) -> Self {\n        unimplemented!()\n    }\n}\npub enum Node {\n    Leaf(LeafNode),\n    Internal(InternalNode),\n}\npub struct MVPTree {\n    pub branch_factor: usize,\n    pub path_length: usize,\n    pub leaf_capacity: usize,\n    pub datatype: MVPDataType,\n    pub pos: i64,\n    pub size: i64,\n    pub pgsize: i64,\n    pub buf: Vec<u8>,\n    pub node: Option<Rc<RefCell<Node>>>,\n    pub distance_function: DistanceFunction,\n}\nimpl MVPTree {\n    pub fn new(branch_factor: usize, path_length: usize, leaf_capacity: usize, datatype: MVPDataType, distance_function: DistanceFunction) -> Self {\n        unimplemented!()\n    }\n    pub fn add(&mut self, points: Vec<MVPDatapoint>) -> MVPError {\n        unimplemented!() \n    }\n    pub fn retrieve(&self, target: &MVPDatapoint, knearest: usize, radius: f32) -> Result<Vec<MVPDatapoint>, MVPError> {\n        unimplemented!()\n    }\n    pub fn write(&self, filename: &str, mode:i32) -> MVPError {\n        unimplemented!()\n    }\n    pub fn print(&self, stream: &mut dyn Write) -> MVPError {\n        unimplemented!()\n    }\n    pub fn clear(&mut self, node: &mut Option<Box<Node>>) {\n        unimplemented!()\n    }\n    pub fn extend_mvpfile(&mut self)-> i32{\n        unimplemented!()\n    }\n}\npub fn mvptree_read(filename: &str, distance_function: DistanceFunction) -> Result<MVPTree, MVPError> {\n    unimplemented!()\n}\nimpl MVPDatapoint {\n    pub fn new(id: String, data: Vec<u8>, data_type: MVPDataType) -> Self {\n        let datalen = data.len();\n        MVPDatapoint {\n            id,\n            data,\n            path: vec![],\n            datalen,\n            data_type,\n        }\n    }\n    pub fn select_vantage_points(&mut self, nb:u32, sv1_pos: i32, sv2_pos: i32, dist: DistanceFunction) -> i32 {\n        unimplemented!()\n    }\n    pub fn find_splits(&mut self, nb:u32, vp:&MVPDatapoint, tree: &MVPTree,  lengthM: u32) -> f32{\n        unimplemented!()\n    }\n    pub fn sort_points(&mut self, nb:u32, sv1_pos: i32, sv2_pos: i32, vp: &MVPDatapoint, tree: &MVPTree, counts: &mut Vec<Vec<i32>>, pivots: Vec<f32>) -> Vec<Vec<Vec<Arc<MVPDatapoint>>>> {\n        unimplemented!()\n    }\n    pub fn find_distance_range_for_vp(&mut self, nb:u32, vp: &MVPDatapoint, tree: &MVPTree, level: i32) -> i32 {\n        unimplemented!()\n    }\n    pub fn write(&self, tree: &MVPTree) -> i64 {\n        unimplemented!()\n    }\n}\npub fn error_to_string(error: MVPError) -> &'static str {\n   unimplemented!()\n}"}
{"ctext": "// from header\n/*\n#ifndef __DICT_H__\n#define __DICT_H__\n#include <stdio.h>\n#include <errno.h>\n#include <wchar.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <stdbool.h>\ntypedef enum\n{\n    DICT_CHAR,     \n    DICT_WCHAR,    \n    DICT_I32,      \n    DICT_U32,      \n    DICT_F32,      \n    DICT_I64,      \n    DICT_U64,      \n    DICT_F64,      \n    DICT_PTR,      \n    DICT_STR,      \n    DICT_STRUCT,   \n} dict_type_t;\ntypedef void (*dict_deep_copy)( void* dest, const void* src );      \ntypedef void (*dict_desctructor)( void* ptr );                      \ntypedef int (*dict_cmpr)( const void* ptr1, const void* ptr2 );     \ntypedef uint64_t (*dict_hash)( const void* ptr );                   \ntypedef void* (*dict_malloc)( size_t size );                        \ntypedef void  (*dict_free)( void* ptr );                            \ntypedef struct\n{\n    dict_malloc    malloc;      \n    dict_free      free;        \n} dict_alloc_t;\ntypedef struct\n{\n    dict_type_t         type;\n    size_t              size;\n    dict_deep_copy      copy;   \n    dict_desctructor    free;   \n    dict_hash           hash;\n    dict_cmpr           cmpr;\n} dict_key_attr_t;\ntypedef struct\n{\n    size_t              size;\n    dict_desctructor    free;   \n} dict_val_attr_t;\ntypedef struct\n{\n    dict_key_attr_t     key;    \n    dict_val_attr_t     val;    \n    dict_alloc_t        alloc;  \n} dict_args_t;\ntypedef struct dict dict_t;\ndict_t*     dict_create( dict_args_t args );                                    \ndict_t*     dict_new( dict_type_t key_type, size_t key_size, size_t val_size ); \nvoid        dict_destroy( dict_t* dict );                                       \nvoid*       dict_get( dict_t* dict, ... );                           \nbool        dict_remove( dict_t* dict, ... );                        \nbool        dict_has( const dict_t* dict, ... );                     \nsize_t      dict_len( const dict_t* dict );                                     \nconst void* dict_key( const dict_t* dict, size_t* size );                       \nvoid*       dict_serialize( const dict_t* dict, size_t* bytes );                \ndict_t*     dict_deserialize( dict_args_t args, const void* data );             \n#define dict_create_args( ... )                     dict_create( (dict_args_t) { __VA_ARGS__ } )\n#endif  \n\n*/\n#include \"dict.h\"\n#define DEFAULT_MOD     8\n#define DEFAULT_STEP    2\n#define HASH_BASE       256LLU\n#define HASH_MOD        1000000007LLU\n#define ASSERT_MEM(x)   if(x==NULL){fprintf(stderr,\"[ERRO]: out of memory.\\n\");exit(1);}\ntypedef struct dict_elem dict_elem_t;\nstruct dict_elem\n{\n    uint64_t        code;\n    dict_elem_t*    prev;\n    dict_elem_t*    next;\n    char            key[];\n};\ntypedef struct dict_list\n{\n    size_t          size;\n    dict_elem_t*    head;\n    dict_elem_t*    tail;\n} dict_list_t;\nstruct dict\n{\n    dict_key_attr_t     key;\n    dict_val_attr_t     val;\n    dict_alloc_t        alloc;\n    size_t              mod;\n    dict_list_t*        list;\n    void*               key_temp;\n};\nstatic inline bool dict_reshape( dict_t* restrict dict, size_t step )\n{\n    size_t old_size = dict->mod;\n    size_t new_size = old_size * step * DEFAULT_STEP;\n    dict_list_t* old_list = dict->list;\n    dict_list_t* new_list = dict->alloc.malloc( sizeof (dict_list_t) * new_size );\n    if ( new_list == NULL ) return false;\n    dict->mod   = new_size;\n    dict->list  = new_list;\n    memset( dict->list, 0, sizeof (dict_list_t) * new_size );\n    dict_elem_t* curr;\n    dict_elem_t* next;\n    uint64_t index;\n    for ( size_t i = 0; i < old_size; i++ )\n    {\n        curr = old_list[i].head;\n        while ( curr != NULL )\n        {\n            next    = curr->next;\n            index   = curr->code % new_size;\n            \n            if ( new_list[ index ].head == NULL )\n            {\n                new_list[ index ].head = new_list[ index ].tail = curr;\n                curr->prev = NULL;\n            }\n            else\n            {\n                new_list[ index ].tail->next = curr;\n                new_list[ index ].tail = curr;\n                curr->prev = new_list[ index ].tail;\n            }\n            new_list[ index ].size++;\n            curr = next;\n        }\n    }\n    for ( size_t i = 0; i < new_size; i++ )\n    {\n        new_list[i].tail->next = NULL;\n    }\n    if ( dict->alloc.free != NULL )\n    {\n        dict->alloc.free( old_list );\n    }\n    return true;\n}\nstatic inline void* dict_get_key( const dict_t* restrict dict, va_list ap )\n{\n    void* key = dict->key_temp;\n    if ( dict->key.copy != NULL )\n    {\n        void* data = va_arg( ap, void* );\n        dict->key.copy( key, data );\n    }\n    else\n    {\n        switch ( dict->key.type )\n        {\n            case DICT_CHAR:         *(char*)        key = va_arg( ap, int );            break;\n            case DICT_WCHAR:        *(wchar_t*)     key = va_arg( ap, int );            break;\n            case DICT_I32:          *(int32_t*)     key = va_arg( ap, int32_t );        break;\n            case DICT_U32:          *(uint32_t*)    key = va_arg( ap, uint32_t );       break;\n            case DICT_F32:          *(float*)       key = va_arg( ap, double );         break;\n            case DICT_I64:          *(int64_t*)     key = va_arg( ap, int64_t );        break;\n            case DICT_U64:          *(uint64_t*)    key = va_arg( ap, uint64_t );       break;\n            case DICT_F64:          *(double*)      key = va_arg( ap, double );         break;\n            case DICT_PTR:          *(void**)       key = va_arg( ap, void* );          break;\n            case DICT_STR:\n            {\n                char* str = va_arg( ap, char* );\n                *(char**) key = dict->alloc.malloc( strlen(str) + 1 );\n                ASSERT_MEM( *(char**) key );\n                strcpy( *(char**) key, str );\n                break;\n            }\n            case DICT_STRUCT:\n            {\n                void* data = va_arg( ap, void* );\n                memcpy( key, data, dict->key.size );\n                break;\n            }\n            default:                fprintf( stderr, \"[ERRO]: illegal type.\\n\" );       exit(1);\n        }\n    }\n    return key;\n}\nstatic inline uint64_t dict_get_hash( const dict_t* restrict dict, void* restrict key )\n{\n    uint64_t code = 0;\n    if ( dict->key.hash != NULL )\n    {\n        code = dict->key.hash( key );\n    }\n    else\n    {\n        size_t length;\n        switch ( dict->key.type )\n        {\n            case DICT_CHAR:         code = *(char*)     key;    break;\n            case DICT_WCHAR:        code = *(wchar_t*)  key;    break;\n            case DICT_I32:          code = *(int32_t*)  key;    break;\n            case DICT_U32:          code = *(uint32_t*) key;    break;\n            case DICT_F32:          code = *(float*)    key;    break;\n            case DICT_I64:          code = *(int64_t*)  key;    break;\n            case DICT_U64:          code = *(uint64_t*) key;    break;\n            case DICT_F64:          code = *(double*)   key;    break;\n            case DICT_PTR:\n            {\n                code = *(uintptr_t*) key;\n                break;\n            }\n            case DICT_STR:          \n                length = strlen( *(char**) key );\n                for ( size_t i = 0; i < length; i++ )\n                {\n                    code = ( code * HASH_BASE + ( *(char**) key )[i] ) % HASH_MOD;\n                }\n                break;\n            case DICT_STRUCT:\n                length = dict->key.size;\n                for ( size_t i = 0; i < length; i++ )\n                {\n                    code = ( code * HASH_BASE + ( (char*) key )[i] ) % HASH_MOD;\n                }\n                break;\n            default:\n            {\n                fprintf( stderr, \"[ERRO]: illegal type.\\n\" );\n                exit(1);\n            }\n        }\n    }\n    return code;\n}\nstatic inline void dict_free_key( const dict_t* restrict dict, void* restrict key )\n{\n    if ( dict->key.copy != NULL && dict->key.free != NULL )\n    {\n        dict->key.free( key );\n    }\n    else if ( dict->key.type == DICT_STR )\n    {\n        dict->alloc.free( *(char**) key );\n    }\n}\nstatic inline void dict_free_val( const dict_t* restrict dict, void* restrict val )\n{\n    if ( dict->val.free != NULL )\n    {\n        dict->val.free( val );\n    }\n}\nstatic inline void dict_free_node( const dict_t* restrict dict, dict_elem_t* restrict node )\n{\n    if ( dict->alloc.free != NULL )\n    {\n        dict->alloc.free( node );\n    }\n}\nstatic inline void dict_delete_node( dict_list_t* restrict list, dict_elem_t* restrict curr )\n{\n    if ( curr == list->head )\n    {\n        list->head = curr->next;\n    }\n    if ( curr == list->tail )\n    {\n        list->tail = curr->prev;\n    }\n    if ( curr->prev != NULL )\n    {\n        curr->prev->next = curr->next;\n    }\n    if ( curr->next != NULL )\n    {\n        curr->next->prev = curr->prev;\n    }\n    list->size--;\n}\ndict_t* dict_create( dict_args_t args )\n{\n    size_t key_size;\n    switch ( args.key.type )\n    {\n        case DICT_CHAR:    key_size = sizeof ( char );                      break;\n        case DICT_WCHAR:   key_size = sizeof ( wchar_t );                   break;\n        case DICT_I32:     key_size = sizeof ( int32_t );                   break;\n        case DICT_U32:     key_size = sizeof ( uint32_t );                  break;\n        case DICT_F32:     key_size = sizeof ( float );                     break;\n        case DICT_I64:     key_size = sizeof ( int64_t );                   break;\n        case DICT_U64:     key_size = sizeof ( uint64_t );                  break;\n        case DICT_F64:     key_size = sizeof ( double );                    break;\n        case DICT_PTR:     key_size = sizeof ( void* );                     break;\n        case DICT_STR:     key_size = sizeof ( char* );                     break;\n        case DICT_STRUCT:  \n        {\n            key_size = ( args.key.size + ( sizeof (uintptr_t) - 1 ) ) & ~( sizeof (uintptr_t) - 1 );\n            break;\n        }\n        default:           fprintf( stderr, \"[ERRO]: illegal type.\\n\" );    exit(1);\n    }\n    size_t val_size = ( args.val.size + ( sizeof (uintptr_t) - 1 ) ) & ~( sizeof (uintptr_t) - 1 );\n    dict_t* dict = NULL;\n    if ( args.alloc.malloc != NULL )\n    {\n        dict = args.alloc.malloc( sizeof (dict_t) );\n        ASSERT_MEM( dict );\n        dict->alloc = args.alloc;\n    }\n    else\n    {\n        dict = malloc( sizeof (dict_t) );\n        ASSERT_MEM( dict );\n        dict->alloc = (dict_alloc_t)\n        {\n            .malloc = malloc,\n            .free   = free,\n        };\n    }\n    dict->key = args.key;\n    dict->key.size = key_size;\n    dict->val = args.val;\n    dict->val.size = val_size;\n    dict->key_temp = dict->alloc.malloc( dict->key.size );\n    ASSERT_MEM( dict->key_temp );\n    dict->mod   = DEFAULT_MOD;\n    dict->list  = dict->alloc.malloc( sizeof (dict_list_t) * dict->mod );\n    ASSERT_MEM( dict->list );\n    memset( dict->list, 0, sizeof (dict_list_t) * dict->mod );\n    return dict;\n}\ndict_t* dict_new( dict_type_t key_type, size_t key_size, size_t val_size )\n{\n    return dict_create( (dict_args_t)\n    {\n        .key = (dict_key_attr_t)\n        {\n            .type = key_type,\n            .size = key_size,\n        },\n        .val = (dict_val_attr_t)\n        {\n            .size = val_size,\n        },\n        .alloc = (dict_alloc_t) { 0 },\n    });\n}\nvoid dict_destroy( dict_t* restrict dict )\n{\n    for ( size_t i = 0; i < dict->mod; i++ )\n    {\n        dict_elem_t* curr = dict->list[i].head;\n        dict_elem_t* next;\n        while ( curr != NULL )\n        {\n            next = curr->next;\n            \n            dict_free_key( dict, curr->key );\n            if ( dict->val.size != 0 )\n            {\n                dict_free_val( dict, curr->key + dict->key.size );\n            }\n            dict_free_node( dict, curr );\n            curr = next;\n        }\n    }\n    if ( dict->alloc.free != NULL )\n    {\n        dict->alloc.free( dict->key_temp );\n        dict->alloc.free( dict->list );\n        dict->alloc.free( dict );\n        dict = NULL;\n    }\n}\nvoid* dict_get( dict_t* restrict dict, ... )\n{\n    va_list ap;\n    va_start( ap, dict );\n    \n    void* key = dict_get_key( dict, ap );\n    va_end(ap);\n    \n    uint64_t code = dict_get_hash( dict, key );\n    \n    size_t index = code % dict->mod;\n    for ( dict_elem_t* curr = dict->list[ index ].head; curr != NULL; curr = curr->next )\n    {\n        if ( curr->code != code ) continue;\n        if ( dict->key.cmpr != NULL )\n        {\n            if ( dict->key.cmpr( curr->key, key ) == 0 )\n            {\n                dict_free_key( dict, key );\n                return curr->key + dict->key.size;\n            }\n        }\n        else\n        {\n            switch ( dict->key.type )\n            {\n                case DICT_CHAR:\n                case DICT_WCHAR:\n                case DICT_I32:\n                case DICT_U32:\n                case DICT_F32:\n                case DICT_I64:\n                case DICT_U64:\n                case DICT_F64:\n                case DICT_PTR:\n                case DICT_STRUCT:\n                {\n                    if ( memcmp( curr->key, key, dict->key.size ) == 0 )\n                    {\n                        dict_free_key( dict, key );\n                        return curr->key + dict->key.size;\n                    }\n                    break;\n                }\n                case DICT_STR:\n                {\n                    if ( strcmp( *(char**) curr->key, *(char**) key ) == 0 )\n                    {\n                        dict_free_key( dict, key );\n                        return curr->key + dict->key.size;\n                    }\n                    break;\n                }\n                default:\n                {\n                    fprintf( stderr, \"[ERRO]: illegal type.\\n\" );\n                    exit(1);\n                }\n            }\n        }\n    }\n    \n    dict_elem_t* elem = dict->alloc.malloc( sizeof (dict_elem_t) + dict->key.size + dict->val.size );\n    ASSERT_MEM( elem );\n    *elem = (dict_elem_t)\n    {\n        .code   = code,\n        .prev   = dict->list[ index ].tail,\n    };\n    memcpy( elem->key, key, dict->key.size );\n    memset( elem->key + dict->key.size, 0, dict->val.size );\n    if ( dict->list[ index ].size == 0 )\n    {\n        dict->list[ index ].head = dict->list[ index ].tail = elem;\n    }\n    else\n    {\n        dict->list[ index ].tail->next = elem;\n        dict->list[ index ].tail = elem;\n    }\n    if ( dict->list[ index ].size++ > dict->mod )\n    {\n        if ( dict_reshape( dict, 1 ) == false )\n        {\n            return NULL;\n        }\n    }\n    return elem->key + dict->key.size;\n}\nbool dict_remove( dict_t* restrict dict, ... )\n{\n    va_list ap;\n    va_start( ap, dict );\n    \n    void* key = dict_get_key( dict, ap );\n    va_end(ap);\n    \n    uint64_t code = dict_get_hash( dict, key );\n    \n    size_t index = code % dict->mod;\n    for ( dict_elem_t* curr = dict->list[ index ].head; curr != NULL; curr = curr->next )\n    {\n        if ( curr->code != code ) continue;\n        if ( dict->key.cmpr != NULL )\n        {\n            if ( dict->key.cmpr( curr->key, key ) == 0 )\n            {\n                \n                dict_free_key( dict, key );\n                dict_delete_node( &dict->list[ index ], curr );\n                \n                dict_free_key( dict, curr->key );\n                dict_free_val( dict, curr->key + dict->key.size );\n                dict_free_node( dict, curr );\n                return true;\n            }\n        }\n        else\n        {\n            switch ( dict->key.type )\n            {\n                case DICT_CHAR:\n                case DICT_WCHAR:\n                case DICT_I32:\n                case DICT_U32:\n                case DICT_F32:\n                case DICT_I64:\n                case DICT_U64:\n                case DICT_F64:\n                case DICT_PTR:\n                case DICT_STRUCT:\n                {\n                    if ( memcmp( curr->key, key, dict->key.size ) == 0 )\n                    {\n                        \n                        dict_free_key( dict, key );\n                        dict_delete_node( &dict->list[ index ], curr );\n                        \n                        dict_free_key( dict, curr->key );\n                        dict_free_val( dict, curr->key + dict->key.size );\n                        dict_free_node( dict, curr );\n                        return true;\n                    }\n                    break;\n                }\n                case DICT_STR:\n                {\n                    if ( strcmp( curr->key, key ) == 0 )\n                    {\n                        \n                        dict_free_key( dict, key );\n                        dict_delete_node( &dict->list[ index ], curr );\n                        \n                        dict_free_key( dict, curr->key );\n                        dict_free_val( dict, curr->key + dict->key.size );\n                        dict_free_node( dict, curr );\n                        return true;\n                    }\n                    break;\n                }\n                default:\n                {\n                    fprintf( stderr, \"[ERRO]: illegal type.\\n\" );\n                    exit(1);\n                }\n            }\n        }\n    }\n    \n    dict_free_key( dict, key );\n    return false;\n}\nbool dict_has( const dict_t* restrict dict, ... )\n{\n    va_list ap;\n    va_start( ap, dict );\n    void* key = dict_get_key( dict, ap );\n    va_end(ap);\n    uint64_t code = dict_get_hash( dict, key );\n    \n    size_t index = code % dict->mod;\n    for ( dict_elem_t* curr = dict->list[ index ].head; curr != NULL; curr = curr->next )\n    {\n        if ( curr->code != code ) continue;\n        if ( dict->key.cmpr != NULL )\n        {\n            if ( dict->key.cmpr( curr->key, key ) == 0 )\n            {\n                return true;\n            }\n        }\n        else\n        {\n            switch ( dict->key.type )\n            {\n                case DICT_CHAR:\n                case DICT_WCHAR:\n                case DICT_I32:\n                case DICT_U32:\n                case DICT_F32:\n                case DICT_I64:\n                case DICT_U64:\n                case DICT_F64:\n                case DICT_PTR:\n                case DICT_STRUCT:\n                {\n                    if ( memcmp( curr->key, key, dict->key.size ) == 0 )\n                    {\n                        dict_free_key( dict, key );\n                        return true;\n                    }\n                    break;\n                }\n                case DICT_STR:\n                {\n                    if ( strcmp( curr->key, key ) == 0 )\n                    {\n                        dict_free_key( dict, key );\n                        return true;\n                    }\n                    break;\n                }\n                default:\n                {\n                    fprintf( stderr, \"[ERRO]: illegal type.\\n\" );\n                    exit(1);\n                }\n            }\n        }\n    }\n    \n    dict_free_key( dict, key );\n    return false;\n}\nsize_t dict_len( const dict_t* restrict dict )\n{\n    size_t size = 0;\n    for ( size_t i = 0; i < dict->mod; i++ )\n    {\n        size += dict->list[i].size;\n    }\n    return size;\n}\nconst void* dict_key( const dict_t* restrict dict, size_t* restrict size )\n{\n    *size = dict_len( dict );\n    if ( *size == 0 )\n    {\n        return NULL;\n    }\n    char* arr = dict->alloc.malloc( dict->key.size * (*size) );\n    size_t index = 0;\n    for ( size_t i = 0; i < dict->mod; i++ )\n    {\n        for ( dict_elem_t* curr = dict->list[i].head; curr != NULL; curr = curr->next )\n        {\n            memcpy( arr + ( dict->key.size * index ), curr->key, dict->key.size );\n            if ( index++ == *size ) return arr;\n        }\n    }\n    return arr;\n}\nvoid* dict_serialize( const dict_t* restrict dict, size_t* restrict bytes )\n{\n    size_t space;\n    if ( bytes == NULL )\n    {\n        bytes = &space;\n    }\n    \n    uint32_t size = dict_len( dict );\n    uint32_t key_val_size[3] = { dict->key.size, dict->val.size, size };\n    size_t   elem_size = dict->key.type == DICT_STR ? sizeof (uint32_t) + dict->val.size : dict->key.size + dict->val.size;\n    \n    if ( dict->key.type == DICT_STR )\n    {\n        *bytes = sizeof (uint32_t) * 3 + size * elem_size;\n    }\n    else\n    {\n        *bytes = sizeof (uint32_t) * 3 + size * elem_size;\n    }\n    \n    #ifdef __STDC_NO_VLA__\n        uint32_t* strlen_table;\n        if (dict->key.type == DICT_STR )\n        {\n            strlen_table = dict->alloc.malloc( sizeof (uint32_t) * size );\n            ASSERT_MEM( strlen_table );\n        }\n    #else\n        uint32_t strlen_table[size];\n    #endif  \n    if ( dict->key.type == DICT_STR )\n    {\n        size_t index = 0;\n        for ( size_t i = 0; i < dict->mod; i++ )\n        {\n            for ( dict_elem_t* curr = dict->list[i].head; curr != NULL; curr = curr->next )\n            {\n                strlen_table[index] = (uint32_t) strlen( *(char**) curr->key );\n                *bytes += strlen_table[index];\n                index++;\n            }\n        }\n    }\n    \n    void* data = dict->alloc.malloc( *bytes );\n    if ( data == NULL )\n    {\n        *bytes = 0;\n        return NULL;\n    }\n    char* ptr = data;\n    \n    memcpy( ptr, key_val_size, sizeof (uint32_t) * 3 );\n    ptr += sizeof (uint32_t) * 3;\n    \n    if ( dict->key.type == DICT_STR )\n    {\n        size_t index = 0;\n        char* str_ptr = ptr + size * elem_size;\n        for ( size_t i = 0; i < dict->mod; i++ )\n        {\n            for ( dict_elem_t* curr = dict->list[i].head; curr != NULL; curr = curr->next )\n            {\n                memcpy( ptr, &strlen_table[index], sizeof (uint32_t) );\n                ptr += sizeof (uint32_t);\n                memcpy( ptr, curr->key + dict->key.size, dict->val.size );\n                ptr += dict->val.size;\n                memcpy( str_ptr, *(char**) curr->key, strlen_table[index] );\n                str_ptr += strlen_table[index];\n                index++;\n            }\n        }\n    }\n    else\n    {\n        for ( size_t i = 0; i < dict->mod; i++ )\n        {\n            for ( dict_elem_t* curr = dict->list[i].head; curr != NULL; curr = curr->next )\n            {\n                memcpy( ptr, curr->key, elem_size );\n                ptr += elem_size;\n            }\n        }\n    }\n    \n    #ifdef __STDC_NO_VLA__\n        if ( dict->key.type != DICT_STR && dict->alloc.free != NULL )\n        {\n            dict->alloc.free( strlen_table );\n        }\n    #endif  \n    return data;\n}\ndict_t* dict_deserialize( dict_args_t args, const void* restrict data )\n{\n    const char* ptr = data;\n    uint32_t key_val_size[3];\n    memcpy( key_val_size, ptr, sizeof (uint32_t) * 3 );\n    ptr += sizeof (uint32_t) * 3;\n    size_t key_size;\n    switch ( args.key.type )\n    {\n        case DICT_CHAR:    key_size = sizeof ( char );                      break;\n        case DICT_WCHAR:   key_size = sizeof ( wchar_t );                   break;\n        case DICT_I32:     key_size = sizeof ( int32_t );                   break;\n        case DICT_U32:     key_size = sizeof ( uint32_t );                  break;\n        case DICT_F32:     key_size = sizeof ( float );                     break;\n        case DICT_I64:     key_size = sizeof ( int64_t );                   break;\n        case DICT_U64:     key_size = sizeof ( uint64_t );                  break;\n        case DICT_F64:     key_size = sizeof ( double );                    break;\n        case DICT_PTR:     key_size = sizeof ( void* );                     break;\n        case DICT_STR:     key_size = sizeof ( char* );                     break;\n        case DICT_STRUCT:\n        {\n            key_size = ( args.key.size + ( sizeof (uintptr_t) - 1 ) ) & ~( sizeof (uintptr_t) - 1 );\n            break;\n        }\n        default:           fprintf( stderr, \"[ERRO]: illegal type.\\n\" );    exit(1);\n    }\n    size_t val_size = ( args.val.size + ( sizeof (uintptr_t) - 1 ) ) & ~( sizeof (uintptr_t) - 1 );\n    if ( key_size != key_val_size[0] )\n    {\n        fprintf( stderr, \"[ERRO]: key type conflict, data corrupted.\\n\" );\n        return NULL;\n    }\n    if ( val_size != key_val_size[1] )\n    {\n        fprintf( stderr, \"[ERRO]: val type conflict, data corrupted.\\n\" );\n        return NULL;\n    }\n    dict_t* dict = NULL;\n    if ( args.alloc.malloc != NULL )\n    {\n        dict = args.alloc.malloc( sizeof (dict_t) );\n        ASSERT_MEM( dict );\n        dict->alloc = args.alloc;\n    }\n    else\n    {\n        dict = malloc( sizeof (dict_t) );\n        ASSERT_MEM( dict );\n        dict->alloc = (dict_alloc_t)\n        {\n            .malloc = malloc,\n            .free   = free,\n        };\n    }\n    dict->key = args.key;\n    dict->key.size = key_size;\n    dict->val = args.val;\n    dict->val.size = val_size;\n    dict->key_temp = dict->alloc.malloc( dict->key.size );\n    ASSERT_MEM( dict->key_temp );\n    dict->mod = DEFAULT_MOD;\n    dict->list  = dict->alloc.malloc( sizeof (dict_list_t) * dict->mod );\n    ASSERT_MEM( dict->list );\n    memset( dict->list, 0, sizeof (dict_list_t) * dict->mod );\n    \n    size_t elem_size = dict->key.type == DICT_STR ? sizeof (uint32_t) + dict->val.size : dict->key.size + dict->val.size;\n    size_t index;\n    uint64_t code;\n    dict_elem_t* elem;\n    if ( dict->key.type == DICT_STR )\n    {\n        const char* str_ptr = ptr + key_val_size[2] * elem_size;\n        for ( size_t i = 0; i < key_val_size[2]; i++ )\n        {\n            elem = dict->alloc.malloc( sizeof (dict_elem_t) + dict->key.size + dict->val.size );\n            ASSERT_MEM( elem );\n            \n            *(char**) elem->key = dict->alloc.malloc( *(uint32_t*) ptr + 1 );\n            ASSERT_MEM( elem->key );\n            memcpy( *(char**) elem->key, str_ptr, *(uint32_t*) ptr );\n            ( *(char**) elem->key )[ *(uint32_t*) ptr ] = 0;\n            str_ptr += *(uint32_t*) ptr;\n            ptr += sizeof (uint32_t);\n            memcpy( elem->key + dict->key.size, ptr, dict->val.size );\n            ptr += dict->val.size;\n            code = dict_get_hash( dict, elem->key );\n            elem->code = code;\n            index = code % dict->mod;\n            elem->prev = dict->list[index].tail;\n            elem->next = NULL;\n            if ( dict->list[index].size++ == 0 )\n            {\n                dict->list[index].head = dict->list[index].tail = elem;\n            }\n            else \n            {\n                dict->list[index].tail->next = elem;\n                dict->list[index].tail = elem;\n            }\n        }\n    }\n    else \n    {\n        for ( size_t i = 0; i < key_val_size[2]; i++ )\n        {\n            elem = dict->alloc.malloc( sizeof (dict_elem_t) + dict->key.size + dict->val.size );\n            ASSERT_MEM( elem );\n            memcpy( elem->key, ptr, elem_size );\n            ptr += elem_size;\n            code = dict_get_hash( dict, elem->key );\n            elem->code = code;\n            index = code % dict->mod;\n            elem->prev = dict->list[index].tail;\n            elem->next = NULL;\n            if ( dict->list[index].size++ == 0 )\n            {\n                dict->list[index].head = dict->list[index].tail = elem;\n            }\n            else\n            {\n                dict->list[index].tail->next = elem;\n                dict->list[index].tail = elem;\n            }\n        }\n    }\n    size_t max = 0;\n    for ( size_t i = 0; i < dict->mod; i++ )\n    {\n        if ( dict->list[i].size > max )\n        {\n            max = dict->list[i].size;\n        }\n    }\n    if ( max <= DEFAULT_MOD ) return dict;\n    max /= DEFAULT_MOD;\n    if ( dict_reshape( dict, max ) == false )\n    {\n        return NULL;\n    }\n    return dict;\n}\n", "rtext": "use core::cmp::Ordering;\nuse std::collections::hash_map::DefaultHasher;\nuse std::hash::{Hash as StdHash, Hasher};\nuse std::sync::Mutex;\n/// A collection of constants matching the original C #defines.\npub const HASH_MOD: u64 = 1000000007;\npub const HASH_BASE: u64 = 256;\npub const DEFAULT_STEP: usize = 2;\npub const DEFAULT_MOD: usize = 8;\n/// Enum corresponding to the C enum `dict_type_t`.\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum DictType {\nChar,\nWChar,\nI32,\nU32,\nF32,\nI64,\nU64,\nF64,\nPtr,\nStr,\nStruct,\n}\n/// A safe function pointer type for deep-copying values.\npub type DictDeepCopy = fn(dest: &mut [u8], src: &[u8]);\n/// A safe function pointer type for destructors.\npub type DictDestructor = fn(data: &mut [u8]);\n/// A safe function pointer type for comparisons.\npub type DictCmpr = fn(a: &[u8], b: &[u8]) -> i32;\n/// A safe function pointer type for hashing.\npub type DictHash = fn(data: &[u8]) -> u64;\n/// A safe function pointer type for memory allocation (unused in safe Rust).\npub type DictMalloc = fn(size: usize) -> Vec<u8>;\n/// A safe function pointer type for freeing allocated memory (unused in safe Rust).\npub type DictFree = fn(_: Vec<u8>);\n/// Corresponds to `dict_alloc_t` in C.\n#[derive(Clone)]\npub struct DictAlloc {\npub malloc: Option<DictMalloc>,\npub free: Option<DictFree>,\n}\n/// Corresponds to `dict_key_attr_t` in C.\n#[derive(Clone)]\npub struct DictKeyAttr {\npub type_: DictType,\npub size: usize,\npub copy: Option<DictDeepCopy>,\npub free: Option<DictDestructor>,\npub hash: Option<DictHash>,\npub cmpr: Option<DictCmpr>,\n}\n/// Corresponds to `dict_val_attr_t` in C.\n#[derive(Clone)]\npub struct DictValAttr {\npub size: usize,\npub free: Option<DictDestructor>,\n}\n/// Corresponds to `dict_args_t` in C.\n#[derive(Clone)]\npub struct DictArgs {\npub key: DictKeyAttr,\npub val: DictValAttr,\npub alloc: DictAlloc,\n}\n/// Each element in the dictionary. Mirrors the struct dict_elem in C.\n/// We store the key bytes in `key` and the value bytes in `val`.\n#[derive(Clone)]\npub struct DictElem {\npub code: u64,    // The hash code\npub key: Vec<u8>, // Owned bytes for the key\npub val: Vec<u8>, // Owned bytes for the value\n}\n/// A bucket (list) in the dictionary. Mirrors dict_list_t in C, but\n/// instead of a linked list, we store a Vec for safe iteration/removal.\n#[derive(Clone)]\npub struct DictBucket {\npub elements: Vec<DictElem>,\n}\n/// Corresponds to `struct dict` in C.\npub struct Dict {\npub key: DictKeyAttr,\npub val: DictValAttr,\npub alloc: DictAlloc,\npub mod_: usize,              // Number of buckets\npub buckets: Vec<DictBucket>, // The buckets array\npub key_temp: Vec<u8>,        // Temporary buffer for constructing a key\npub keys_dump: Vec<u8>,       // Unused here; effectively replaced by a safe approach\npub count: usize,             // Number of elements total\n}\n/// Create a dictionary using detailed arguments. Matches C's dict_create().\npub fn dict_create(args: DictArgs) -> Dict {\n    unimplemented!()\n}\n/// Create a dictionary with derived arguments. Matches C's dict_new().\npub fn dict_new(key_type: DictType, key_size: usize, val_size: usize) -> Dict {\n    unimplemented!()\n}\n/// Destroy a dictionary. Matches C's dict_destroy().\n/// In Rust, memory is freed automatically, but we emulate calling destructors if provided.\npub fn dict_destroy(dict: &mut Dict) {\n    unimplemented!()\n}\n/// Retrieve or create a value from the dictionary. In C, this used varargs. Here, we\n/// accept a slice of bytes as the key. Returns a mutable slice of the value,\n/// or None if something went wrong. Matches C's dict_get(dict_t*, ...).\n///\n/// IMPORTANT NOTE on borrow-checking:\n/// We must avoid returning a reference while also reshaping or re-borrowing the dictionary.\n/// To fix borrow issues, we do this in distinct steps:\n/// 1) Prepare the final key bytes. 2) Compute hash/code/index. 3) Search for existing element.\n/// 4) If not found, insert a new element. 5) Possibly reshape. 6) Perform a final search\n/// to retrieve a &mut reference. This ensures no overlapping mutable borrows exist during\n/// the function body.\npub fn dict_get<'dict>(dict: &'dict mut Dict, key_data: &[u8]) -> Option<&'dict mut [u8]> {\n    unimplemented!()\n}\n/// Remove a value from the dictionary. Matches C's dict_remove(dict_t*, ...).\n/// Returns true if the element was found and removed.\npub fn dict_remove(dict: &mut Dict, key_data: &[u8]) -> bool {\n    unimplemented!()\n}\n/// Check if a key exists in the dictionary. Matches C's dict_has(const dict_t*, ...).\npub fn dict_has(dict: &Dict, key_data: &[u8]) -> bool {\n    unimplemented!()\n}\n/// Return the number of elements in the dictionary. Matches C's dict_len().\npub fn dict_len(dict: &Dict) -> usize {\n    unimplemented!()\n}\n/// Return a snapshot of all keys. In C, it returns a newly allocated array of all keys\n/// (size = key.size * dict_len). This is not thread-safe in the original C usage. In\n/// safe Rust, we simulate returning a static buffer by leaking the allocation. This\n/// avoids unsafe code, but does leak memory for each call. Matches C's dict_key().\npub fn dict_key(dict: &Dict, size: &mut usize) -> Option<&'static [u8]> {\n    unimplemented!()\n}\n/// Serialize a dictionary into a contiguous Vec<u8>. Matches C's dict_serialize().\npub fn dict_serialize(dict: &Dict, bytes: &mut usize) -> Option<Vec<u8>> {\n    unimplemented!()\n}\n/// Deserialize a dictionary from a slice. Matches C's dict_deserialize().\npub fn dict_deserialize(args: DictArgs, data: &[u8]) -> Dict {\n    unimplemented!()\n}\n/// Convenience function to create a dictionary using inline arguments, mirroring the\n/// C macro dict_create_args(...).\npub fn dict_create_args(args: DictArgs) -> Dict {\n    unimplemented!()\n}\n/// The original dict_key_equals. Kept for signature consistency but not used internally\n/// to avoid borrow conflicts.\npub fn dict_key_equals(dict: &Dict, a: &[u8], b: &[u8]) -> bool {\n    unimplemented!()\n}\n/// Not used in this design, but signature is kept.\npub fn dict_delete_node(_list: &mut DictBucket, _curr: &mut DictElem) {\n// no-op in this safe design\n}\n/// The original dict_free_val. Kept for signature consistency.\npub fn dict_free_val(dict: &Dict, val: &mut [u8]) {\n    unimplemented!()\n}\n/// Not used in pure Rust version, matching signature only.\npub fn dict_get_key(_dict: &Dict) -> Option<&mut [u8]> {\n    unimplemented!()\n}\n/// Internal function to reshape the dictionary. Matches C's dict_reshape().\n/// We re-allocate and re-hash all elements with new capacity = old * step * DEFAULT_STEP.\npub fn dict_reshape(dict: &mut Dict, step: usize) -> bool {\n    unimplemented!()\n}\n/// Internal function to free a node. Matches C's dict_free_node().\npub fn dict_free_node(_dict: &Dict, _node: &mut DictElem) {\n    unimplemented!()\n}\n/// Internal function to free a dictionary key. Kept for signature consistency.\npub fn dict_free_key(dict: &Dict, key: &mut [u8]) {\n    unimplemented!()\n}\n/// The original dict_get_hash. Kept for signature consistency but not used internally\n/// to avoid borrow conflicts.\npub fn dict_get_hash(dict: &Dict, key: &[u8]) -> u64 {\n    unimplemented!()\n}"}
{"ctext": "// from header\n/*\n\n#ifndef MATRIX_MULTIPLICATION_MATRIX_GENERATOR_H\n#define MATRIX_MULTIPLICATION_MATRIX_GENERATOR_H\n#include <stdbool.h>\n#define ARRAY_TYPE float\nint generate_matrix(ARRAY_TYPE*** matrix, int x, int y, bool random);\nint free_matrix(ARRAY_TYPE*** matrix, int x);\nint algorithm1(ARRAY_TYPE** m1, ARRAY_TYPE** m2, ARRAY_TYPE** r, int x1, int y1, int x2, int y2);\nint algorithm3(ARRAY_TYPE** m1, ARRAY_TYPE** m2, ARRAY_TYPE** r, int x1, int y1, int x2, int y2);\nint algorithm2( ARRAY_TYPE **a,  ARRAY_TYPE **bb, ARRAY_TYPE **c, int size);\nint multiply(ARRAY_TYPE** m1, ARRAY_TYPE** m2, ARRAY_TYPE** r, int x1, int y1, int x2, int y2, int method);\n#endif \n\n*/\n\n#include <malloc.h>\n#include <stdlib.h>\n#include <immintrin.h>\n#include \"matrix.h\"\nint generate_matrix(ARRAY_TYPE*** matrix, int x, int y, bool random){\n    *matrix = malloc(sizeof(ARRAY_TYPE*) * x);\n    if(!random){\n        for (int i = 0; i < x; ++i) {\n            (*matrix)[i] = malloc(sizeof(ARRAY_TYPE) * x);\n            for (int j = 0; j < y; ++j) {\n                (*matrix)[i][j] = (ARRAY_TYPE)(j + i * x);\n            }\n        }\n    }else{\n        for (int i = 0; i < x; ++i) {\n            (*matrix)[i] = malloc(sizeof(ARRAY_TYPE) * y);\n            for (int j = 0; j < y; ++j) {\n                (*matrix)[i][j] = (ARRAY_TYPE)rand();\n            }\n        }\n    }\n    return 0;\n}\nint free_matrix(ARRAY_TYPE*** matrix, int x){\n    for (int i = 0; i < x; ++i) {\n        free((*matrix)[i]);\n    }\n    free(*matrix);\n    *matrix = NULL;\n    return 0;\n}\nint multiply(ARRAY_TYPE** m1, ARRAY_TYPE** m2, ARRAY_TYPE** r, int x1, int y1, int x2, int y2, int method){\n    if(y1 - x2){\n        printf(\"The number of columns in the first matrix must be equal to the number of rows in the second matrix. \\n\");\n        return -1;\n    }\n    switch (method) {\n        case 1:\n            algorithm1(m1, m2, r, x1, y1, x2, y2);\n            break;\n        case 2:\n            algorithm2(m1, m2, r, x1);\n            break;\n        case 3:\n            algorithm3(m1, m2, r, x1, y1, x2, y2);\n            break;\n        default:\n            printf(\"Choose the correct method!\\n\");\n            return -1;\n    }\n    return 0;\n}\nint algorithm1(ARRAY_TYPE** m1, ARRAY_TYPE** m2, ARRAY_TYPE** r, int x1, int y1, int x2, int y2){\n    for (int i = 0; i < x1; ++i) {\n        for (int j = 0; j < y2; ++j) {\n            r[i][j] = 0;\n            for (int k = 0; k < y1; ++k) {\n                r[i][j] += m1[i][k] * m2[k][j];\n            }\n        }\n    }\n    return 0;\n}\nint algorithm2( ARRAY_TYPE **a,  ARRAY_TYPE **bb, ARRAY_TYPE **c, int size){\n    ARRAY_TYPE** b = malloc(sizeof(ARRAY_TYPE*) * size);\n    for (int i = 0; i < size; ++i) {\n        b[i] = malloc(sizeof(ARRAY_TYPE) * size);\n        for (int j = 0; j < size;) {\n            b[i][j] = bb[j][i];\n            c[i][j] = 0;\n            j++;\n            b[i][j] = bb[j][i];\n            c[i][j] = 0;\n            j++;\n            b[i][j] = bb[j][i];\n            c[i][j] = 0;\n            j++;\n            b[i][j] = bb[j][i];\n            c[i][j] = 0;\n            j++;\n            b[i][j] = bb[j][i];\n            c[i][j] = 0;\n            j++;\n            b[i][j] = bb[j][i];\n            c[i][j] = 0;\n            j++;\n            b[i][j] = bb[j][i];\n            c[i][j] = 0;\n            j++;\n            b[i][j] = bb[j][i];\n            c[i][j] = 0;\n            j++;\n        }\n    }\n    for (int i = 0; i < size; ++i) {\n        for (int j = 0; j < size; j+=8) {\n            __m256 m_a =  _mm256_loadu_ps(a[i] + j);\n            for (int k = 0; k < size; k++) {\n                __m256 m_b =  _mm256_loadu_ps(b[k] + j);\n                __m256 m_c = _mm256_mul_ps(m_a, m_b);\n                c[i][k] += m_c[0];\n                c[i][k] += m_c[1];\n                c[i][k] += m_c[2];\n                c[i][k] += m_c[3];\n                c[i][k] += m_c[4];\n                c[i][k] += m_c[5];\n                c[i][k] += m_c[6];\n                c[i][k] += m_c[7];\n                k++;\n                m_b =  _mm256_loadu_ps(b[k] + j);\n                m_c = _mm256_mul_ps(m_a, m_b);\n                c[i][k] += m_c[0];\n                c[i][k] += m_c[1];\n                c[i][k] += m_c[2];\n                c[i][k] += m_c[3];\n                c[i][k] += m_c[4];\n                c[i][k] += m_c[5];\n                c[i][k] += m_c[6];\n                c[i][k] += m_c[7];\n                k++;\n                m_b =  _mm256_loadu_ps(b[k] + j);\n                m_c = _mm256_mul_ps(m_a, m_b);\n                c[i][k] += m_c[0];\n                c[i][k] += m_c[1];\n                c[i][k] += m_c[2];\n                c[i][k] += m_c[3];\n                c[i][k] += m_c[4];\n                c[i][k] += m_c[5];\n                c[i][k] += m_c[6];\n                c[i][k] += m_c[7];\n                k++;\n                m_b =  _mm256_loadu_ps(b[k] + j);\n                m_c = _mm256_mul_ps(m_a, m_b);\n                c[i][k] += m_c[0];\n                c[i][k] += m_c[1];\n                c[i][k] += m_c[2];\n                c[i][k] += m_c[3];\n                c[i][k] += m_c[4];\n                c[i][k] += m_c[5];\n                c[i][k] += m_c[6];\n                c[i][k] += m_c[7];\n                k++;\n                m_b =  _mm256_loadu_ps(b[k] + j);\n                m_c = _mm256_mul_ps(m_a, m_b);\n                c[i][k] += m_c[0];\n                c[i][k] += m_c[1];\n                c[i][k] += m_c[2];\n                c[i][k] += m_c[3];\n                c[i][k] += m_c[4];\n                c[i][k] += m_c[5];\n                c[i][k] += m_c[6];\n                c[i][k] += m_c[7];\n                k++;\n                m_b =  _mm256_loadu_ps(b[k] + j);\n                m_c = _mm256_mul_ps(m_a, m_b);\n                c[i][k] += m_c[0];\n                c[i][k] += m_c[1];\n                c[i][k] += m_c[2];\n                c[i][k] += m_c[3];\n                c[i][k] += m_c[4];\n                c[i][k] += m_c[5];\n                c[i][k] += m_c[6];\n                c[i][k] += m_c[7];\n                k++;\n                m_b =  _mm256_loadu_ps(b[k] + j);\n                m_c = _mm256_mul_ps(m_a, m_b);\n                c[i][k] += m_c[0];\n                c[i][k] += m_c[1];\n                c[i][k] += m_c[2];\n                c[i][k] += m_c[3];\n                c[i][k] += m_c[4];\n                c[i][k] += m_c[5];\n                c[i][k] += m_c[6];\n                c[i][k] += m_c[7];\n                k++;\n                m_b =  _mm256_loadu_ps(b[k] + j);\n                m_c = _mm256_mul_ps(m_a, m_b);\n                c[i][k] += m_c[0];\n                c[i][k] += m_c[1];\n                c[i][k] += m_c[2];\n                c[i][k] += m_c[3];\n                c[i][k] += m_c[4];\n                c[i][k] += m_c[5];\n                c[i][k] += m_c[6];\n                c[i][k] += m_c[7];\n            }\n            j+=8; if(j >= size) break;\n            m_a =  _mm256_loadu_ps(a[i] + j);\n            for (int k = 0; k < size; k++) {\n                __m256 m_b =  _mm256_loadu_ps(b[k] + j);\n                __m256 m_c = _mm256_mul_ps(m_a, m_b);\n                c[i][k] += m_c[0];\n                c[i][k] += m_c[1];\n                c[i][k] += m_c[2];\n                c[i][k] += m_c[3];\n                c[i][k] += m_c[4];\n                c[i][k] += m_c[5];\n                c[i][k] += m_c[6];\n                c[i][k] += m_c[7];\n                k++;\n                m_b =  _mm256_loadu_ps(b[k] + j);\n                m_c = _mm256_mul_ps(m_a, m_b);\n                c[i][k] += m_c[0];\n                c[i][k] += m_c[1];\n                c[i][k] += m_c[2];\n                c[i][k] += m_c[3];\n                c[i][k] += m_c[4];\n                c[i][k] += m_c[5];\n                c[i][k] += m_c[6];\n                c[i][k] += m_c[7];\n                k++;\n                m_b =  _mm256_loadu_ps(b[k] + j);\n                m_c = _mm256_mul_ps(m_a, m_b);\n                c[i][k] += m_c[0];\n                c[i][k] += m_c[1];\n                c[i][k] += m_c[2];\n                c[i][k] += m_c[3];\n                c[i][k] += m_c[4];\n                c[i][k] += m_c[5];\n                c[i][k] += m_c[6];\n                c[i][k] += m_c[7];\n                k++;\n                m_b =  _mm256_loadu_ps(b[k] + j);\n                m_c = _mm256_mul_ps(m_a, m_b);\n                c[i][k] += m_c[0];\n                c[i][k] += m_c[1];\n                c[i][k] += m_c[2];\n                c[i][k] += m_c[3];\n                c[i][k] += m_c[4];\n                c[i][k] += m_c[5];\n                c[i][k] += m_c[6];\n                c[i][k] += m_c[7];\n                k++;\n                m_b =  _mm256_loadu_ps(b[k] + j);\n                m_c = _mm256_mul_ps(m_a, m_b);\n                c[i][k] += m_c[0];\n                c[i][k] += m_c[1];\n                c[i][k] += m_c[2];\n                c[i][k] += m_c[3];\n                c[i][k] += m_c[4];\n                c[i][k] += m_c[5];\n                c[i][k] += m_c[6];\n                c[i][k] += m_c[7];\n                k++;\n                m_b =  _mm256_loadu_ps(b[k] + j);\n                m_c = _mm256_mul_ps(m_a, m_b);\n                c[i][k] += m_c[0];\n                c[i][k] += m_c[1];\n                c[i][k] += m_c[2];\n                c[i][k] += m_c[3];\n                c[i][k] += m_c[4];\n                c[i][k] += m_c[5];\n                c[i][k] += m_c[6];\n                c[i][k] += m_c[7];\n                k++;\n                m_b =  _mm256_loadu_ps(b[k] + j);\n                m_c = _mm256_mul_ps(m_a, m_b);\n                c[i][k] += m_c[0];\n                c[i][k] += m_c[1];\n                c[i][k] += m_c[2];\n                c[i][k] += m_c[3];\n                c[i][k] += m_c[4];\n                c[i][k] += m_c[5];\n                c[i][k] += m_c[6];\n                c[i][k] += m_c[7];\n                k++;\n                m_b =  _mm256_loadu_ps(b[k] + j);\n                m_c = _mm256_mul_ps(m_a, m_b);\n                c[i][k] += m_c[0];\n                c[i][k] += m_c[1];\n                c[i][k] += m_c[2];\n                c[i][k] += m_c[3];\n                c[i][k] += m_c[4];\n                c[i][k] += m_c[5];\n                c[i][k] += m_c[6];\n                c[i][k] += m_c[7];\n            }\n            j+=8; if(j >= size) break;\n            m_a =  _mm256_loadu_ps(a[i] + j);\n            for (int k = 0; k < size; k++) {\n                __m256 m_b =  _mm256_loadu_ps(b[k] + j);\n                __m256 m_c = _mm256_mul_ps(m_a, m_b);\n                c[i][k] += m_c[0];\n                c[i][k] += m_c[1];\n                c[i][k] += m_c[2];\n                c[i][k] += m_c[3];\n                c[i][k] += m_c[4];\n                c[i][k] += m_c[5];\n                c[i][k] += m_c[6];\n                c[i][k] += m_c[7];\n                k++;\n                m_b =  _mm256_loadu_ps(b[k] + j);\n                m_c = _mm256_mul_ps(m_a, m_b);\n                c[i][k] += m_c[0];\n                c[i][k] += m_c[1];\n                c[i][k] += m_c[2];\n                c[i][k] += m_c[3];\n                c[i][k] += m_c[4];\n                c[i][k] += m_c[5];\n                c[i][k] += m_c[6];\n                c[i][k] += m_c[7];\n                k++;\n                m_b =  _mm256_loadu_ps(b[k] + j);\n                m_c = _mm256_mul_ps(m_a, m_b);\n                c[i][k] += m_c[0];\n                c[i][k] += m_c[1];\n                c[i][k] += m_c[2];\n                c[i][k] += m_c[3];\n                c[i][k] += m_c[4];\n                c[i][k] += m_c[5];\n                c[i][k] += m_c[6];\n                c[i][k] += m_c[7];\n                k++;\n                m_b =  _mm256_loadu_ps(b[k] + j);\n                m_c = _mm256_mul_ps(m_a, m_b);\n                c[i][k] += m_c[0];\n                c[i][k] += m_c[1];\n                c[i][k] += m_c[2];\n                c[i][k] += m_c[3];\n                c[i][k] += m_c[4];\n                c[i][k] += m_c[5];\n                c[i][k] += m_c[6];\n                c[i][k] += m_c[7];\n                k++;\n                m_b =  _mm256_loadu_ps(b[k] + j);\n                m_c = _mm256_mul_ps(m_a, m_b);\n                c[i][k] += m_c[0];\n                c[i][k] += m_c[1];\n                c[i][k] += m_c[2];\n                c[i][k] += m_c[3];\n                c[i][k] += m_c[4];\n                c[i][k] += m_c[5];\n                c[i][k] += m_c[6];\n                c[i][k] += m_c[7];\n                k++;\n                m_b =  _mm256_loadu_ps(b[k] + j);\n                m_c = _mm256_mul_ps(m_a, m_b);\n                c[i][k] += m_c[0];\n                c[i][k] += m_c[1];\n                c[i][k] += m_c[2];\n                c[i][k] += m_c[3];\n                c[i][k] += m_c[4];\n                c[i][k] += m_c[5];\n                c[i][k] += m_c[6];\n                c[i][k] += m_c[7];\n                k++;\n                m_b =  _mm256_loadu_ps(b[k] + j);\n                m_c = _mm256_mul_ps(m_a, m_b);\n                c[i][k] += m_c[0];\n                c[i][k] += m_c[1];\n                c[i][k] += m_c[2];\n                c[i][k] += m_c[3];\n                c[i][k] += m_c[4];\n                c[i][k] += m_c[5];\n                c[i][k] += m_c[6];\n                c[i][k] += m_c[7];\n                k++;\n                m_b =  _mm256_loadu_ps(b[k] + j);\n                m_c = _mm256_mul_ps(m_a, m_b);\n                c[i][k] += m_c[0];\n                c[i][k] += m_c[1];\n                c[i][k] += m_c[2];\n                c[i][k] += m_c[3];\n                c[i][k] += m_c[4];\n                c[i][k] += m_c[5];\n                c[i][k] += m_c[6];\n                c[i][k] += m_c[7];\n            }\n            j+=8; if(j >= size) break;\n            m_a =  _mm256_loadu_ps(a[i] + j);\n            for (int k = 0; k < size; k++) {\n                __m256 m_b =  _mm256_loadu_ps(b[k] + j);\n                __m256 m_c = _mm256_mul_ps(m_a, m_b);\n                c[i][k] += m_c[0];\n                c[i][k] += m_c[1];\n                c[i][k] += m_c[2];\n                c[i][k] += m_c[3];\n                c[i][k] += m_c[4];\n                c[i][k] += m_c[5];\n                c[i][k] += m_c[6];\n                c[i][k] += m_c[7];\n                k++;\n                m_b =  _mm256_loadu_ps(b[k] + j);\n                m_c = _mm256_mul_ps(m_a, m_b);\n                c[i][k] += m_c[0];\n                c[i][k] += m_c[1];\n                c[i][k] += m_c[2];\n                c[i][k] += m_c[3];\n                c[i][k] += m_c[4];\n                c[i][k] += m_c[5];\n                c[i][k] += m_c[6];\n                c[i][k] += m_c[7];\n                k++;\n                m_b =  _mm256_loadu_ps(b[k] + j);\n                m_c = _mm256_mul_ps(m_a, m_b);\n                c[i][k] += m_c[0];\n                c[i][k] += m_c[1];\n                c[i][k] += m_c[2];\n                c[i][k] += m_c[3];\n                c[i][k] += m_c[4];\n                c[i][k] += m_c[5];\n                c[i][k] += m_c[6];\n                c[i][k] += m_c[7];\n                k++;\n                m_b =  _mm256_loadu_ps(b[k] + j);\n                m_c = _mm256_mul_ps(m_a, m_b);\n                c[i][k] += m_c[0];\n                c[i][k] += m_c[1];\n                c[i][k] += m_c[2];\n                c[i][k] += m_c[3];\n                c[i][k] += m_c[4];\n                c[i][k] += m_c[5];\n                c[i][k] += m_c[6];\n                c[i][k] += m_c[7];\n                k++;\n                m_b =  _mm256_loadu_ps(b[k] + j);\n                m_c = _mm256_mul_ps(m_a, m_b);\n                c[i][k] += m_c[0];\n                c[i][k] += m_c[1];\n                c[i][k] += m_c[2];\n                c[i][k] += m_c[3];\n                c[i][k] += m_c[4];\n                c[i][k] += m_c[5];\n                c[i][k] += m_c[6];\n                c[i][k] += m_c[7];\n                k++;\n                m_b =  _mm256_loadu_ps(b[k] + j);\n                m_c = _mm256_mul_ps(m_a, m_b);\n                c[i][k] += m_c[0];\n                c[i][k] += m_c[1];\n                c[i][k] += m_c[2];\n                c[i][k] += m_c[3];\n                c[i][k] += m_c[4];\n                c[i][k] += m_c[5];\n                c[i][k] += m_c[6];\n                c[i][k] += m_c[7];\n                k++;\n                m_b =  _mm256_loadu_ps(b[k] + j);\n                m_c = _mm256_mul_ps(m_a, m_b);\n                c[i][k] += m_c[0];\n                c[i][k] += m_c[1];\n                c[i][k] += m_c[2];\n                c[i][k] += m_c[3];\n                c[i][k] += m_c[4];\n                c[i][k] += m_c[5];\n                c[i][k] += m_c[6];\n                c[i][k] += m_c[7];\n                k++;\n                m_b =  _mm256_loadu_ps(b[k] + j);\n                m_c = _mm256_mul_ps(m_a, m_b);\n                c[i][k] += m_c[0];\n                c[i][k] += m_c[1];\n                c[i][k] += m_c[2];\n                c[i][k] += m_c[3];\n                c[i][k] += m_c[4];\n                c[i][k] += m_c[5];\n                c[i][k] += m_c[6];\n                c[i][k] += m_c[7];\n            }\n        }\n    }\n}\nint algorithm3(ARRAY_TYPE** m1, ARRAY_TYPE** m2, ARRAY_TYPE** r, int x1, int y1, int x2, int y2){\n    for (int i = 0; i < x1; ++i) {\n        for (int j = 0; j < y2; ++j) {\n            r[i][j] = 0;\n        }\n    }\n    for (int i = 0; i < x1; ++i) {\n        for (int k = 0; k < y1; ++k){\n            for (int j = 0; j < y2; ++j) {\n                r[i][j] += m1[i][k] * m2[k][j];\n            }\n        }\n    }\n    return 0;\n}", "rtext": "pub fn generate_matrix(x: usize, y: usize, random: bool) -> Vec<Vec<f32>> {\n    unimplemented!()\n}\npub fn free_matrix(matrix: &mut Vec<Vec<f32>>) -> i32 {\n    unimplemented!()\n}\npub fn multiply(m1: &[Vec<f32>], m2: &[Vec<f32>], result: &mut [Vec<f32>], method: i32) -> i32 {\n    unimplemented!()\n}\npub fn algorithm1(m1: &[Vec<f32>], m2: &[Vec<f32>], result: &mut [Vec<f32>]) {\n    unimplemented!()\n}\npub fn algorithm3(m1: &[Vec<f32>], m2: &[Vec<f32>], result: &mut [Vec<f32>]) {\n    unimplemented!()\n}\npub fn algorithm2(m1: &[Vec<f32>], m2: &[Vec<f32>], result: &mut [Vec<f32>]) {\n    unimplemented!()\n}"}
{"ctext": "// from header\n/*\n\n#ifndef MATRIX_MULTIPLICATION_UTILS_H\n#define MATRIX_MULTIPLICATION_UTILS_H\nint print_array(float **matrix, int x, int y, char* name, char* type);\nint print_float_array(float ** matrix, int x, int y);\n#endif \n\n*/\n\n#include <stdio.h>\n#include <string.h>\nint print_float_array(float ** matrix, int x, int y){\n    for (int i = 0; i < x; ++i) {\n        for (int j = 0; j < y; ++j) {\n            printf(\"%10.2f \", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\nint print_array(float **matrix, int x, int y, char* name, char* type){\n    printf(\"-------------%s--------------\\n\", name);\n    if(!strcmp(type, \"float\")){\n        print_float_array(matrix, x, y);\n    }else{\n        printf(\"unsupported %s\", type);\n    }\n    return 0;\n}\n", "rtext": "pub fn print_array(matrix: &[Vec<f32>], name: &str, typ: &str) -> i32 {\n    unimplemented!()\n}\npub fn print_float_array(matrix: &[Vec<f32>]) -> i32 {\n    unimplemented!()\n}"}
{"ctext": "// from header\n/*\n#ifndef CHTRIE\n#define CHTRIE\nstruct chtrie_edge {\n\tstruct chtrie_edge *next;\n\tint from, sym, to;\n};\ntypedef struct {\n\tstruct chtrie_edge **etab;\n\tint *idxpool, *idxptr, idxmax;\t\n\tint maxn, alphsz, ecap;\n} chtrie;\nchtrie *chtrie_alloc(size_t n, size_t m);\nint chtrie_walk(chtrie *tr, int from, int sym, int creat);\nvoid chtrie_del(chtrie *tr, int from, int sym);\nvoid chtrie_free(chtrie *tr);\n#endif\n\n*/\n#include <stddef.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include \"chtrie.h\"\n#define SZ_MAX ((size_t)-1)\n#define MIN(x, y) ((x)<(y)?(x):(y))\nchtrie *chtrie_alloc(size_t n, size_t m)\n{\n\tchtrie *tr;\n\tif (n < 1) n = 1;\n\tif (m < 1) m = 1;\n\tif (n > INT_MAX || m > INT_MAX) {\n\t\terrno = ERANGE;\n\t\tgoto err;\n\t}\n\tif (MIN(INT_MAX, SZ_MAX) - (n-1) < (n-1) / 3) {\n\t\terrno = ERANGE;\n\t\tgoto err;\n\t}\n\tif (!(tr = calloc(1, sizeof *tr)))\n\t\tgoto err;\n\ttr->maxn = n;\n\ttr->alphsz = m;\n\ttr->ecap = (n-1) + (n-1)/3;\n\tif (!(tr->etab = calloc(tr->ecap, sizeof tr->etab[0])))\n\t\tgoto free_tr;\n\tif (!(tr->idxpool = calloc(n, sizeof tr->idxpool[0])))\n\t\tgoto free_ecap;\n\ttr->idxmax = 1;\n\ttr->idxptr = tr->idxpool;\n\treturn tr;\nfree_ecap:\n\tfree(tr->etab);\nfree_tr:\n\tfree(tr);\nerr:\n\treturn NULL;\n}\nint chtrie_walk(chtrie *tr, int from, int sym, int creat)\n{\n\tstruct chtrie_edge *p;\n\tunsigned long h;\n\th = (unsigned long)from*tr->alphsz + sym;\n\th %= tr->ecap;\n\tfor (p = tr->etab[h]; p; p = p->next)\n\t\tif (p->from == from && p->sym == sym)\n\t\t\treturn p->to;\n\tif (creat) {\n\t\tif (tr->idxptr == tr->idxpool && tr->idxmax >= tr->maxn) {\n\t\t\terrno = ENOMEM;\n\t\t\treturn -1;\n\t\t}\n\t\tif (!(p = malloc(sizeof *p)))\n\t\t\treturn -1;\n\t\tp->next = tr->etab[h];\n\t\ttr->etab[h] = p;\n\t\tp->from = from;\n\t\tp->sym = sym;\n\t\tif (tr->idxptr != tr->idxpool)\n\t\t\tp->to = *--tr->idxptr;\n\t\telse\n\t\t\tp->to = tr->idxmax++;\n\t\treturn p->to;\n\t}\n\treturn -1;\n}\nvoid chtrie_del(chtrie *tr, int from, int sym)\n{\n\tstruct chtrie_edge *p, *q;\n\tunsigned long h;\n\th = (unsigned long)from*tr->alphsz + sym;\n\th %= tr->ecap;\n\tfor (p = tr->etab[h], q = NULL; p; q = p, p = p->next)\n\t\tif (p->from == from && p->sym == sym)\n\t\t\tbreak;\n\tif (!p)\n\t\treturn;\n\tif (q)\n\t\tq->next = p->next;\n\telse\n\t\ttr->etab[h] = NULL;\n\t*tr->idxptr++ = p->to;\n\tfree(p);\n}\nvoid chtrie_free(chtrie *tr)\n{\n\tstruct chtrie_edge *p, *q;\n\tint i;\n\tfor (i = 0; i < tr->ecap; i++) {\n\t\tp = tr->etab[i];\n\t\twhile (p) {\n\t\t\tq = p->next;\n\t\t\tfree(p);\n\t\t\tp = q;\n\t\t}\n\t}\n\tfree(tr->etab);\n\tfree(tr->idxpool);\n\tfree(tr);\n}\n", "rtext": "// Generated Rust Code\nuse std::collections::VecDeque;\npub const SZ_MAX: usize = usize::MAX;\n// Struct Definitions\npub struct ChtrieEdge {\n    pub next: Option<Box<ChtrieEdge>>,\n    pub from: i32,\n    pub sym: i32,\n    pub to: i32,\n}\npub struct Chtrie {\n    pub etab: Vec<Option<Box<ChtrieEdge>>>,\n    pub idxpool: VecDeque<i32>,\n    pub idxptr: i32,\n    pub idxmax: i32,\n    pub maxn: i32,\n    pub alphsz: i32,\n    pub ecap: i32,\n}\nimpl Chtrie {\n    pub fn new(n: usize, m: usize) -> Option<Self> {\n        unimplemented!()\n    }\n    pub fn walk(&mut self, from: i32, sym: i32, creat: i32) -> i32 {\n        unimplemented!()\n    }\n    pub fn del(&mut self, from: i32, sym: i32) {\n        unimplemented!()\n    }\n    pub fn free(&mut self) {\n        unimplemented!()\n    }\n}\npub fn chtrie_walk(trie: &mut Chtrie, from: i32, sym: i32, creat: i32) -> i32 {\n    unimplemented!()\n}\npub fn chtrie_del(trie: &mut Chtrie, from: i32, sym: i32) {\n    unimplemented!()\n}"}
{"ctext": "// from header\n/*\n#pragma once\n#include <stdint.h>\ntypedef struct GFC GFC;\nstruct GFC {\n  uint64_t M;  \n  uint64_t r;  \n  uint64_t a;\n  uint64_t b;\n  uint32_t* speck_exp;\n};\nGFC* gfc_init(uint64_t range, uint64_t rounds, uint64_t seed);\nvoid gfc_destroy(GFC* gfc);\nuint64_t gfc_decrypt(const GFC* gfc, uint64_t m);\nuint64_t gfc_encrypt(const GFC* gfc, uint64_t m);\n\n*/\n#include <gfc/gfc.h>\n#include <math.h>\n#include <stdlib.h>\n#define SPECK_TYPE uint32_t\n#define SPECK_ROUNDS 27\n#define SPECK_KEY_LEN 4\n#define ROR(x, r) ((x >> r) | (x << ((sizeof(SPECK_TYPE) * 8) - r)))\n#define ROL(x, r) ((x << r) | (x >> ((sizeof(SPECK_TYPE) * 8) - r)))\n#define R(x, y, k) (x = ROR(x, 8), x += y, x ^= k, y = ROL(y, 3), y ^= x)\nvoid speck_expand(SPECK_TYPE const K[SPECK_KEY_LEN],\n                  SPECK_TYPE S[SPECK_ROUNDS]) {\n  SPECK_TYPE i, b = K[0];\n  SPECK_TYPE a[SPECK_KEY_LEN - 1];\n  for (i = 0; i < (SPECK_KEY_LEN - 1); i++) {\n    a[i] = K[i + 1];\n  }\n  S[0] = b;\n  for (i = 0; i < SPECK_ROUNDS - 1; i++) {\n    R(a[i % (SPECK_KEY_LEN - 1)], b, i);\n    S[i + 1] = b;\n  }\n}\nvoid speck_encrypt(SPECK_TYPE const pt[2], SPECK_TYPE ct[2],\n                   SPECK_TYPE const K[SPECK_ROUNDS]) {\n  SPECK_TYPE i;\n  ct[0] = pt[0];\n  ct[1] = pt[1];\n  for (i = 0; i < SPECK_ROUNDS; i++) {\n    R(ct[1], ct[0], K[i]);\n  }\n}\nuint64_t F(const GFC *gfc, const uint64_t j, const uint64_t R) {\n  uint64_t enc;\n  const uint32_t *key = gfc->speck_exp + (j - 1) * SPECK_ROUNDS;\n  speck_encrypt((const uint32_t *)&R, (uint32_t *)&enc, key);\n  return enc;\n}\nuint64_t fe(const GFC *gfc, const uint64_t m) {\n  uint64_t L, R, tmp;\n  L = m % gfc->a;\n  R = m / gfc->a;\n  for (uint64_t j = 1; j <= gfc->r; j++) {\n    \n    if (j & 1) {\n      tmp = (L + F(gfc, j, R)) % gfc->a;\n    } else {\n      tmp = (L + F(gfc, j, R)) % gfc->b;\n    }\n    L = R;\n    R = tmp;\n  }\n  if (gfc->r & 1) {\n    return gfc->a * L + R;\n  } else {\n    return gfc->a * R + L;\n  }\n}\nuint64_t fe_inv(const GFC *gfc, const uint64_t m) {\n  uint64_t L, R, tmp;\n  if (gfc->r & 1) {\n    R = m % gfc->a;\n    L = m / gfc->a;\n  } else {\n    L = m % gfc->a;\n    R = m / gfc->a;\n  }\n  for (uint64_t j = gfc->r; j >= 1; j--) {\n    if (j & 1) {\n      \n      \n      tmp = (R + gfc->a - (F(gfc, j, L) % gfc->a)) % gfc->a;\n      \n    } else {\n      tmp = (R + gfc->b - (F(gfc, j, L) % gfc->b)) % gfc->b;\n      \n    }\n    R = L;\n    L = tmp;\n  }\n  return gfc->a * R + L;\n}\nGFC *gfc_init(uint64_t range, uint64_t rounds, uint64_t seed) {\n  GFC *gfc = calloc(1, sizeof(GFC));\n  if (gfc == NULL) {\n    return NULL;\n  }\n  gfc->M = range;\n  gfc->r = rounds;\n  \n  \n  const double tmp = ceil(sqrt((double)range));\n  gfc->a = (uint64_t)tmp;\n  gfc->b = (uint64_t)tmp;\n  \n  gfc->speck_exp = calloc(gfc->r * SPECK_ROUNDS, sizeof(uint32_t));\n  for (uint64_t i = 0; i < gfc->r; i++) {\n    const uint64_t key[2] = {seed, i};\n    speck_expand((const uint32_t *)key, gfc->speck_exp + i * SPECK_ROUNDS);\n  }\n  return gfc;\n}\nvoid gfc_destroy(GFC *gfc) {\n  free(gfc->speck_exp);\n  free(gfc);\n}\nuint64_t gfc_decrypt(const GFC *gfc, const uint64_t m) {\n  uint64_t c = fe_inv(gfc, m);\n  while (c >= gfc->M) {\n    c = fe_inv(gfc, c);\n  }\n  return c;\n}\nuint64_t gfc_encrypt(const GFC *gfc, const uint64_t m) {\n  uint64_t c = fe(gfc, m);\n  while (c >= gfc->M) {\n    c = fe(gfc, c);\n  }\n  return c;\n}\n", "rtext": "use std::f64::consts::SQRT_2;\n/// Constants for Speck encryption\nconst SPECK_ROUNDS: usize = 27;\nconst SPECK_KEY_LEN: usize = 4;\nfn ror(x: u32, r: u32) -> u32 {\n    unimplemented!()\n}\nfn rol(x: u32, r: u32) -> u32 {\n    unimplemented!()\n}\nfn round(x: &mut u32, y: &mut u32, k: u32) {\n    unimplemented!()\n}\n#[derive(Debug)]\npub struct GFC {\n    m: u64,       // Range\n    r: u64,       // Number of Feistel rounds\n    a: u64,\n    b: u64,\n    speck_exp: Vec<u32>,\n}\nimpl GFC {\n    /// Initialize the GFC structure\n    pub fn new(range: u64, rounds: u64, seed: u64) -> Self {\n        unimplemented!()\n    }\n    /// Encrypt using the Feistel cipher\n    pub fn encrypt(&self, m: u64) -> u64 {\n        unimplemented!()\n    }\n    /// Decrypt using the Feistel cipher\n    pub fn decrypt(&self, m: u64) -> u64 {\n        unimplemented!()\n    }\n    /// Function F for Feistel cipher using Speck encryption\n    fn f(&self, j: u64, r: u64) -> u64 {\n        unimplemented!()\n    }\n    /// Function fe[r, a, b] for encryption\n    fn fe(&self, m: u64) -> u64 {\n        unimplemented!()\n    }\n    /// Function fe^-1[r, a, b] for decryption\n    fn fe_inv(&self, m: u64) -> u64 {\n        unimplemented!()\n    }\n}\n/// Speck key expansion\nfn speck_expand(key: &[u32; SPECK_KEY_LEN], round_keys: &mut [u32]) {\n    unimplemented!()\n}\n/// Speck encryption function\nfn speck_encrypt(pt: &[u32; 2], ct: &mut [u32; 2], key: &[u32]) {\n    unimplemented!()\n}"}
{"ctext": "// from header\n/*\nvoid ulidgen_r(char[27]);\n\n*/\n\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\nvoid\nulidgen_r(char ulid[27])\n{\n\tstatic const char *b32alphabet = \"0123456789ABCDEFGHJKMNPQRSTVWXYZ\";\n\tchar *buf = ulid + 10;\n\tint same = 1;\n\tulid[26] = 0;\n\tstruct timespec tv;\n\tclock_gettime(CLOCK_REALTIME, &tv);\n\tuint64_t t = tv.tv_sec*1000 + tv.tv_nsec/1000000;\n\tfor (int i = 9; i >= 0; i--, t /= 32)\n\t\tif (ulid[i] != b32alphabet[t % 32])\n\t\t\tulid[i] = b32alphabet[t % 32], same = 0;\n\tif (same) {             \n\t\tint i = 15;\n\t\twhile (i >= 0 && buf[i] == 'Z')\n\t\t\tbuf[i--] = '0';\n\t\tif (i < 0) {\n                        \n\t\t\tnanosleep(&(struct timespec) { 0, 1234567 }, 0);\n\t\t\tulidgen_r(ulid);\n\t\t\treturn;\n\t\t}\n\t\tchar *s = strchr(b32alphabet, buf[i]);\n\t\tif (s) {\n\t\t\tbuf[i] = *(s+1);\n\t\t\treturn;\n\t\t}\n\t\t\n\t}\n\tunsigned char rnd[16];  \n\tif (getentropy(rnd, sizeof rnd) < 0)\n\t\tabort();\n\tfor (int i = 0; i < 16; i++)\n\t\tbuf[i] = b32alphabet[rnd[i] % 32];\n}\n", "rtext": "// Import statements\nuse crate::{ulidgen};\n// Constants\npub const ULID_LENGTH: usize = 27;\n// Function Declarations\npub fn ulidgen_r(ulid: &mut [char; ULID_LENGTH]) {\n    unimplemented!()\n}"}
{"ctext": "\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include \"ulid.h\"\nint\nmain(int argc, char *argv[])\n{\n\tchar ulid[27] = { 0 };\n\tint c;\n\tlong n = 1;\n\tint tflag = 0;\n        while ((c = getopt(argc, argv, \"n:t\")) != -1)\n\t        switch (c) {\n\t        case 'n': n = atol(optarg); break;\n\t        case 't': tflag = 1; break;\n\t        }\n\tif (tflag) {\n\t\tchar *line = 0;\n\t\tsize_t linelen = 0;\n\t\tsetvbuf(stdout, 0, _IOLBF, 0);\n\t\twhile (getdelim(&line, &linelen, '\\n', stdin) != -1) {\n\t\t\tulidgen_r(ulid);\n\t\t\tprintf(\"%s %s\", ulid, line);\n\t\t}\n\t} else {\n\t\tfor (long i = 0; i < n; i++) {\n\t\t\tulidgen_r(ulid);\n\t\t\tputs(ulid);\n\t\t}\n\t}\n\tfflush(0);\n\texit(!!ferror(stdout));\n}\n", "rtext": "// Import statements\nuse crate::{ulid};\n// Function Declarations\npub fn main(argc: i32, argv: &[&str]) -> i32 {\n    unimplemented!()\n}"}
{"ctext": "// from header\n/*\n#ifndef __QUADTREE_H__\n#define __QUADTREE_H__\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n#define QUADTREE_VERSION \"0.0.1\"\n#include <stdlib.h>\n#include <math.h>\ntypedef struct quadtree_point {\n  double x;\n  double y;\n} quadtree_point_t;\ntypedef struct quadtree_bounds {\n  quadtree_point_t *nw;\n  quadtree_point_t *se;\n  double width;\n  double height;\n} quadtree_bounds_t;\ntypedef struct quadtree_node {\n  struct quadtree_node *ne;\n  struct quadtree_node *nw;\n  struct quadtree_node *se;\n  struct quadtree_node *sw;\n  quadtree_bounds_t *bounds;\n  quadtree_point_t  *point;\n  void *key;\n} quadtree_node_t;\ntypedef struct quadtree {\n  quadtree_node_t *root;\n  void (*key_free)(void *key);\n  unsigned int length;\n} quadtree_t;\nquadtree_point_t*\nquadtree_point_new(double x, double y);\nvoid\nquadtree_point_free(quadtree_point_t *point);\nquadtree_bounds_t*\nquadtree_bounds_new(void);\nvoid\nquadtree_bounds_extend(quadtree_bounds_t *bounds, double x, double y);\nvoid\nquadtree_bounds_free(quadtree_bounds_t *bounds);\nquadtree_node_t*\nquadtree_node_new(void);\nvoid\nquadtree_node_free(quadtree_node_t *node, void (*value_free)(void*));\nint\nquadtree_node_ispointer(quadtree_node_t *node);\nint\nquadtree_node_isempty(quadtree_node_t *node);\nint\nquadtree_node_isleaf(quadtree_node_t *node);\nvoid\nquadtree_node_reset(quadtree_node_t* node, void (*key_free)(void*));\nquadtree_node_t*\nquadtree_node_with_bounds(double minx, double miny, double maxx, double maxy);\nquadtree_t*\nquadtree_new(double minx, double miny, double maxx, double maxy);\nvoid\nquadtree_free(quadtree_t *tree);\nquadtree_point_t*\nquadtree_search(quadtree_t *tree, double x, double y);\nint\nquadtree_insert(quadtree_t *tree, double x, double y, void *key);\nvoid\nquadtree_walk(quadtree_node_t *root,\n              void (*descent)(quadtree_node_t *node),\n              void (*ascent)(quadtree_node_t *node));\n#ifdef __cplusplus\n}\n#endif\n#endif\n\n*/\n#include \"quadtree.h\"\n#include <stdio.h>\nstatic int\nsplit_node_(quadtree_t *tree, quadtree_node_t *node);\nstatic int\ninsert_(quadtree_t* tree, quadtree_node_t *root, quadtree_point_t *point, void *key);\nstatic int\nnode_contains_(quadtree_node_t *outer, quadtree_point_t *it);\nstatic quadtree_node_t *\nget_quadrant_(quadtree_node_t *root, quadtree_point_t *point);\nstatic int\nnode_contains_(quadtree_node_t *outer, quadtree_point_t *it) {\n  return outer->bounds != NULL\n      && outer->bounds->nw->x <= it->x\n      && outer->bounds->nw->y >= it->y\n      && outer->bounds->se->x >= it->x\n      && outer->bounds->se->y <= it->y;\n}\nstatic void\nelision_(void* key){}\nstatic void\nreset_node_(quadtree_t *tree, quadtree_node_t *node){\n  if(tree->key_free != NULL) {\n    quadtree_node_reset(node, tree->key_free);\n  } else {\n    quadtree_node_reset(node, elision_);\n  }\n}\nstatic quadtree_node_t *\nget_quadrant_(quadtree_node_t *root, quadtree_point_t *point) {\n  if(node_contains_(root->nw, point)) return root->nw;\n  if(node_contains_(root->ne, point)) return root->ne;\n  if(node_contains_(root->sw, point)) return root->sw;\n  if(node_contains_(root->se, point)) return root->se;\n  return NULL;\n}\nstatic int\nsplit_node_(quadtree_t *tree, quadtree_node_t *node){\n  quadtree_node_t *nw;\n  quadtree_node_t *ne;\n  quadtree_node_t *sw;\n  quadtree_node_t *se;\n  quadtree_point_t *old;\n  void *key;\n  double x  = node->bounds->nw->x;\n  double y  = node->bounds->nw->y;\n  double hw = node->bounds->width / 2;\n  double hh = node->bounds->height / 2;\n                                    \n  if(!(nw = quadtree_node_with_bounds(x,      y - hh,     x + hw,     y))) return 0;\n  if(!(ne = quadtree_node_with_bounds(x + hw, y - hh,     x + hw * 2, y))) return 0;\n  if(!(sw = quadtree_node_with_bounds(x,      y - hh * 2, x + hw,     y - hh))) return 0;\n  if(!(se = quadtree_node_with_bounds(x + hw, y - hh * 2, x + hw * 2, y - hh))) return 0;\n  node->nw = nw;\n  node->ne = ne;\n  node->sw = sw;\n  node->se = se;\n  old = node->point;\n  key   = node->key;\n  node->point = NULL;\n  node->key   = NULL;\n  return insert_(tree, node, old, key);\n}\nstatic quadtree_point_t*\nfind_(quadtree_node_t* node, double x, double y) {\n  if(!node){\n    return NULL;\n  }\n  if(quadtree_node_isleaf(node)){\n    if(node->point->x == x && node->point->y == y)\n      return node->point;\n  } else if(quadtree_node_ispointer(node)){\n    quadtree_point_t test;\n    test.x = x;\n    test.y = y;\n    return find_(get_quadrant_(node, &test), x, y);\n  }\n  return NULL;\n}\nstatic int\ninsert_(quadtree_t* tree, quadtree_node_t *root, quadtree_point_t *point, void *key) {\n  if(quadtree_node_isempty(root)){\n    root->point = point;\n    root->key   = key;\n    return 1; \n  } else if(quadtree_node_isleaf(root)){\n    if(root->point->x == point->x && root->point->y == point->y){\n      reset_node_(tree, root);\n      root->point = point;\n      root->key   = key;\n      return 2; \n    } else {\n      if(!split_node_(tree, root)){\n        return 0; \n      }\n      return insert_(tree, root, point, key);\n    }\n  } else if(quadtree_node_ispointer(root)){\n    quadtree_node_t* quadrant = get_quadrant_(root, point);\n    return quadrant == NULL ? 0 : insert_(tree, quadrant, point, key);\n  }\n  return 0;\n}\nquadtree_t*\nquadtree_new(double minx, double miny, double maxx, double maxy) {\n  quadtree_t *tree;\n  if(!(tree = malloc(sizeof(*tree))))\n    return NULL;\n  tree->root = quadtree_node_with_bounds(minx, miny, maxx, maxy);\n  if(!(tree->root))\n    return NULL;\n  tree->key_free = NULL;\n  tree->length = 0;\n  return tree;\n}\nint\nquadtree_insert(quadtree_t *tree, double x, double y, void *key) {\n  quadtree_point_t *point;\n  int insert_status;\n  if(!(point = quadtree_point_new(x, y))) return 0;\n  if(!node_contains_(tree->root, point)){\n    quadtree_point_free(point);\n    return 0;\n  }\n  \n  if(!(insert_status = insert_(tree, tree->root, point, key))){\n    quadtree_point_free(point);\n    return 0;\n  }\n  if (insert_status == 1) tree->length++;\n  return insert_status;\n}\nquadtree_point_t*\nquadtree_search(quadtree_t *tree, double x, double y) {\n  return find_(tree->root, x, y);\n}\nvoid\nquadtree_free(quadtree_t *tree) {\n  if(tree->key_free != NULL) {\n    quadtree_node_free(tree->root, tree->key_free);\n  } else {\n    quadtree_node_free(tree->root, elision_);\n  }\n  free(tree);\n}\nvoid\nquadtree_walk(quadtree_node_t *root, void (*descent)(quadtree_node_t *node),\n                                     void (*ascent)(quadtree_node_t *node)) {\n  (*descent)(root);\n  if(root->nw != NULL) quadtree_walk(root->nw, descent, ascent);\n  if(root->ne != NULL) quadtree_walk(root->ne, descent, ascent);\n  if(root->sw != NULL) quadtree_walk(root->sw, descent, ascent);\n  if(root->se != NULL) quadtree_walk(root->se, descent, ascent);\n  (*ascent)(root);\n}\n", "rtext": "pub mod quadtree {\n    #[derive(Default)]\n    pub struct QuadtreePoint {\n        pub x: f64,\n        pub y: f64,\n    }\n    impl QuadtreePoint {\n        pub fn quadtree_point_new(x: f64, y: f64) -> QuadtreePoint {\n            unimplemented!()\n        }\n        pub fn quadtree_point_free(&self) {\n            unimplemented!()\n        } \n    }\n    #[derive(Default)]\n    pub struct QuadtreeBounds {\n        pub nw: Option<Box<QuadtreePoint>>,\n        pub se: Option<Box<QuadtreePoint>>,\n        pub width: f64,\n        pub height: f64,\n    }\n    impl QuadtreeBounds {\n        pub fn quadtree_bounds_new() -> QuadtreeBounds {\n            unimplemented!()\n        }\n        pub fn quadtree_bounds_extend(&self, x: f64, y: f64) {\n            unimplemented!()\n        }\n        pub fn quadtree_bounds_free(&self) {\n            unimplemented!()\n        }\n    }\n    #[derive(Default)]\n    pub struct QuadtreeNode<T> {\n        pub ne: Option<Box<QuadtreeNode<T>>>,\n        pub nw: Option<Box<QuadtreeNode<T>>>,\n        pub se: Option<Box<QuadtreeNode<T>>>,\n        pub sw: Option<Box<QuadtreeNode<T>>>,\n        pub bounds: Option<Box<QuadtreeBounds>>,\n        pub point: Option<Box<QuadtreePoint>>,\n        pub key: Option<T>,\n    }\n    impl <T> QuadtreeNode<T> {\n        pub fn node_contains_(&mut self, point: Option<Box<QuadtreePoint>>) {\n            unimplemented!()\n        }\n        pub fn get_quadrant_(&mut self, point: Option<Box<QuadtreePoint>>) {\n            unimplemented!()\n        }\n        pub fn find_(&mut self, x: f64, y: f64) {\n            unimplemented!()\n        }\n        pub fn quadtree_node_new() -> QuadtreeNode<T> {\n            unimplemented!()\n        }\n        pub fn quadtree_node_free(&self, value_free: Option<fn(Option<T>)>,) {\n            unimplemented!()\n        }\n        pub fn quadtree_node_ispointer(&self) -> bool {\n            unimplemented!()\n        }\n        pub fn quadtree_node_isempty(&self) -> bool {\n            unimplemented!()\n        }\n        pub fn quadtree_node_isleaf(&self) -> bool {\n            unimplemented!()\n        }\n        pub fn quadtree_node_reset(&self, value_free: Option<fn(Option<T>)>,) {\n            unimplemented!()\n        }\n        pub fn quadtree_node_with_bounds(minx: f64, miny: f64, maxx: f64, maxy: f64) -> QuadtreeNode<T> {\n            unimplemented!()\n        }\n    }\n    #[derive(Default)]\n    pub struct Quadtree<T> {\n        pub root: Option<Box<QuadtreeNode<T>>>,\n        pub key_free: Option<fn(Option<T>)>,\n        pub length: u32,\n    }\n    impl <T> Quadtree<T> {\n        pub fn split_node_(&mut self, node: Option<Box<QuadtreeNode<T>>>) {\n            unimplemented!()\n        }\n        pub fn insert_(&mut self, tree: Option<Box<QuadtreeNode<T>>>, point: Option<Box<QuadtreePoint>>, key: Option<T>) {\n            unimplemented!()\n        }\n        pub fn quadtree_new(minx: f64, miny: f64, maxx: f64, maxy: f64) -> Quadtree<T> {\n            unimplemented!()\n        }\n        pub fn quadtree_free(&mut self) {\n            unimplemented!()\n        }\n        pub fn quadtree_search(&self, x: f64, y: f64) -> &mut Option<Box<QuadtreePoint>> {\n            unimplemented!()\n        }\n        pub fn quadtree_insert(&self, x: f64, y: f64, key: Option<T>) -> bool {\n            unimplemented!()\n        }\n        pub fn quadtree_walk(&self, descent: fn(&mut Option<Box<QuadtreeNode<T>>>), ascent: fn(&mut Option<Box<QuadtreeNode<T>>>)) {\n            unimplemented!()\n        }\n    }\n}\n// Helper function\npub fn elision_<T>(key: Option<Box<T>>) {unimplemented!()}"}
{"ctext": "// from header\n/*\n#define ColorOff \"\\033[0m\"\n#define Red \"\\033[0;31m\"\n#define Green \"\\033[0;32m\"\n#define Yellow \"\\033[0;33m\"\n#define Blue \"\\033[0;34m\"\n#define Purple \"\\033[0;35m\"\n#define Cyan \"\\033[0;36m\"\n#define White \"\\033[0;37m\"\n#define RightMargin 5\n#define DefaultName \"unnamed\"\ntypedef struct Command {\n  char key;\n  char* name;\n  char* command;\n  struct Command* children;\n  struct Command* next;\n} Command;\nCommand* NewCommand(char key, char* name, char* command);\nint CommandRun(Command *c) ;\nvoid CommandAddChild(Command *c, Command *child) ;\nCommand *FindCommand(Command *c, char key) ;\nvoid TreeAddCommand(Command *tree, char *keys, char *name, char *command) ;\nint PrintCommand(Command *c);\nchar getch(void);\nchar* ReadFile(char* file) ;\nchar* ReadField(char** file, char *field);\nchar* ReadUntilEOL(char** file);\nvoid ReadLine(Command* c, char** file);\nvoid ClearLines(int count);\nvoid LoadFile(Command *c, char *file);\nvoid Start(Command *c);\n\n*/\n#include \"hydra.h\"\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/ioctl.h>\n#include <termios.h>\n#include <unistd.h>\n#include <string.h>\nCommand* NewCommand(char key, char* name, char* command) {\n  Command* cmd = (Command*) calloc(1, sizeof(Command));\n  cmd->key = key;\n  cmd->name = name;\n  cmd->command = command;\n  return cmd;\n}\nint CommandRun(Command *c) {\n  if (c != NULL && c->command != NULL)\n    return fprintf(stdout, \"%s\", c->command);\n  return 0;\n}\nvoid CommandAddChild(Command *c, Command *child) {\n  if (c->children == NULL) {\n    c->children = child;\n    return;\n  }\n  if(c->children->key > child->key) {\n    child->next = c->children;\n    c->children = child;\n    return;\n  }\n  Command *lastChild = c->children;\n  while (lastChild->next != NULL && lastChild->next->key <= child->key){\n    lastChild = lastChild->next;\n  }\n  child->next = lastChild->next;\n  lastChild->next = child;\n}\nCommand *FindCommand(Command *c, char key) {\n  Command *child = c->children;\n  while (child != NULL && child->key != key)\n    child = child->next;\n  return child;\n}\nvoid TreeAddCommand(Command *tree, char *keys, char *name, char *command) {\n  Command *c = FindCommand(tree, *keys);\n  if (*(keys + 1) == 0) {\n    if( c == NULL ) {\n      CommandAddChild(tree, NewCommand(*keys, name, command));\n    } else { \n      c->name = name;\n      c->command = command;\n    }\n    return;\n  }\n  if (c == NULL) {\n    c = NewCommand(*keys, DefaultName, 0);\n    CommandAddChild(tree, c);\n  }\n  TreeAddCommand(c, keys + 1, name, command);\n}\nint PrintCommand(Command *c) {\n  struct winsize terminal;\n  ioctl(STDERR_FILENO, TIOCGWINSZ, &terminal);\n  int width = terminal.ws_col;\n  \n  int lines = 0;\n  if (c->name) {\n    fprintf(stderr, \"%s%s:%s\\n\", Blue, c->name, ColorOff);\n    lines++;\n  }\n  \n  int maxLineWidth = 0;\n  Command *child = c->children;\n  while (child) {\n    int lineWidth = strlen(child->name);\n    if (lineWidth > maxLineWidth)\n      maxLineWidth = lineWidth;\n    child = child->next;\n  }\n  maxLineWidth += RightMargin;\n  if (maxLineWidth > width)\n    maxLineWidth = width;\n  int itemsPerRow =\n      width /\n      (maxLineWidth + 5); \n  child = c->children;\n  int currentItem = 0;\n  while (child) {\n    currentItem++;\n    if (child->children != 0) {\n      fprintf(stderr, \"%s%c%s %s\u2794%s %s+%-*s%s\", Yellow, child->key, ColorOff, Purple,\n             ColorOff, Blue, maxLineWidth, child->name, ColorOff);\n    } else {\n      fprintf(stderr, \"%s%c%s %s\u2794%s  %-*s\", Yellow, child->key, ColorOff, Purple,\n             ColorOff, maxLineWidth, child->name);\n    }\n    if (currentItem % itemsPerRow == 0) {\n      fprintf(stderr, \"\\n\");\n      lines ++;\n    }\n    child = child->next;\n  }\n  fprintf(stderr, \"\\n\");\n  lines ++;\n  return lines;\n}\nchar getch(void) {\n  struct termios old = {0};\n  if (tcgetattr(0, &old) < 0) perror(\"tcsetattr()\");\n  tcflag_t oldflags = old.c_lflag;\n  old.c_lflag &= ~ICANON;\n  old.c_lflag &= ~ECHO;\n  old.c_cc[VMIN] = 1;\n  old.c_cc[VTIME] = 0;\n  if (tcsetattr(0, TCSANOW, &old) < 0) perror(\"tcsetattr ICANON\");\n  char buf = 0;\n  if (read(0, &buf, 1) < 0) perror(\"read()\");\n  old.c_lflag = oldflags;\n  if (tcsetattr(0, TCSADRAIN, &old) < 0) perror(\"tcsetattr ~ICANON\");\n  return (buf);\n}\nchar* ReadFile(char* file) {\n  FILE* f = fopen(file, \"r\");\n  if( f == NULL ) {\n    perror(\"Failed to open file\");\n    exit(EXIT_FAILURE);\n  }\n  fseek(f, 0, SEEK_END);\n  long fileSize = ftell(f);\n  rewind(f);\n  char* content = (char*) calloc(fileSize+1, sizeof(char));\n  fread(content, fileSize, 1, f);\n  fclose(f);\n  return content;\n}\nchar* ReadField(char** file, char *field) {\n  char* key = *file;\n  while(**file != ',' && **file != '\\n' && **file != 0) (*file)++;\n  if( **file != ',') {\n    fprintf(stderr, \"Found incorrect end after %s, found: %c\", field, * *file);\n    exit(EXIT_FAILURE);\n  }\n  **file = 0;\n  (*file)++;\n  return key;\n}\nchar* ReadUntilEOL(char** file) {\n  char* s = *file;\n  while(**file != '\\n' && **file != 0) (*file)++;\n  if(**file == '\\n') {\n    **file = 0;\n    (*file)++;\n  }\n  return s;\n}\nvoid ReadLine(Command* c, char** file) {\n  char* key = ReadField(file, \"key\");\n  char* name = ReadField(file, \"name\");\n  char* command = ReadUntilEOL(file);\n  TreeAddCommand(c, key, name, command);\n}\nvoid ClearLines(int count) {\n  \n  \n  \n  setbuf(stdout, NULL);\n  for (int i = 0; i < count; i++)\n    fprintf(stderr, \"\\033[A\\r\\33[2K\");\n}\nvoid LoadFile(Command *c, char *file) {\n  char *content = ReadFile(file);\n  while (*content != 0)\n    ReadLine(c, &content);\n}\nvoid Start(Command *c) {\n  while (c != NULL && c->children != NULL) {\n    int lastPrintedLines = PrintCommand(c);\n    c = FindCommand(c, getch());\n    ClearLines(lastPrintedLines);\n    if( CommandRun(c) > 0 ){\n      return;\n    };\n  }\n}\n", "rtext": "pub const RED: &str = \"\\x1b[0;31m\";\npub const WHITE: &str = \"\\x1b[0;37m\";\npub const COLOR_OFF: &str = \"\\x1b[0m\";\npub const PURPLE: &str = \"\\x1b[0;35m\";\npub const GREEN: &str = \"\\x1b[0;32m\";\npub const YELLOW: &str = \"\\x1b[0;33m\";\npub const BLUE: &str = \"\\x1b[0;34m\";\npub const RIGHT_MARGIN: usize = 5;\npub const CYAN: &str = \"\\x1b[0;36m\";\npub const DEFAULT_NAME: &str = \"unnamed\";\npub struct Command {\n    pub key: char,\n    pub name: String,\n    pub command: String,\n    pub children: Option<Box<Command>>,\n    pub next: Option<Box<Command>>,\n}\nimpl Command {\n    pub fn new(key: char, name: String, command: String) -> Self {\n        Command {\n            key,\n            name,\n            command,\n            children: None,\n            next: None,\n        }\n    }\n}\npub fn read_field(file: &mut &[u8], field: &str) -> String {\n    unimplemented!()\n}\npub fn load_file(c: &mut Command, file: &str) {\n    unimplemented!()\n}\npub fn start(c: &Command) {\n    unimplemented!()\n}\npub fn tree_add_command(tree: &mut Command, keys: &str, name: &str, command: &str) {\n    unimplemented!()\n}\npub fn read_line(c: &mut Command, file: &mut &[u8]) {\n    unimplemented!()\n}\npub fn command_add_child(c: &mut Command, child: Command) {\n    unimplemented!()\n}\npub fn getch() -> char {\n    unimplemented!()\n}\npub fn print_command(c: &Command) -> i32 {\n    unimplemented!()\n}\npub fn clear_lines(count: i32) {\n    unimplemented!()\n}\npub fn find_command(c: &Command, key: char) -> Option<&Command> {\n    unimplemented!()\n}\npub fn read_until_eol(file: &mut &[u8]) -> String {\n    unimplemented!()\n}\npub fn read_file(file: &str) -> String {\n    unimplemented!()\n}\npub fn command_run(c: &Command) -> i32 {\n    unimplemented!()\n}"}
{"ctext": "// from header\n/*\n#ifndef BHSHELL_H\n#define BHSHELL_H\n#include \"input.h\"\nvoid bhshell_loop();\nint bhshell_execute(command* cmd);\nint bhshell_launch(command* cmd); \nint bhshell_cd(char** args);\nint bhshell_help(char** args);\nint bhshell_exit(char** args);\nint bhshell_num_builtins();\nvoid write_to_redirect(int redirect_fd[2], command* cmd);\n#endif \n\n*/\n#include <linux/limits.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <strings.h>\n#include <unistd.h>\n#include <stdbool.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <stdbool.h>\n#include \"include/dynamicarr.h\"\n#include \"include/input.h\"\n#include \"include/bhshell.h\"\n#include \"include/xalloc.h\"\n#define BUF_SIZE 64\nchar* bhshell_builtin_str[] = {\n\t\"cd\",\n\t\"help\",\n\t\"exit\",\n};\nint (*bhshell_builtin_func[]) (char**) = {\n\t&bhshell_cd,\n\t&bhshell_help,\n\t&bhshell_exit,\n};\nvoid bhshell_loop() {\n\tchar** args; \n\tint status = 1;\n\tdo {\n\t\tchar* dir = getcwd(NULL, 0);\n\t\tif (!dir) exit(EXIT_FAILURE);\n\t\tprintf(\"[%s] $ \", dir);\n\t\tchar* line = bhshell_read_line();\n\t\tcommand* cmd = bhshell_parse(line);\n\t\tif (cmd == NULL) {\n\t\t\tprintf(\"Invalid Command\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tstatus = bhshell_execute(cmd); \n\t\t\n\t\tfree(dir);\n\t\tfree(line);\n\t\tdestroy_command(cmd);\n\t} while(status); \n}\nint bhshell_execute(command* cmd) {\n\tif (cmd->args[0] == NULL) {\n\t\treturn 1;\n\t}\n\tfor (int i = 0; i < bhshell_num_builtins(); i++) {\n\t\tif (strcmp(cmd->args[0], bhshell_builtin_str[i]) == 0) {\n\t\t\treturn (*bhshell_builtin_func[i])(cmd->args);\n\t\t}\n\t}\n\treturn bhshell_launch(cmd);\n}\nint bhshell_launch(command* cmd) {\n\tpid_t pid;\n\tint status;\n\tint redirect_fd[2];\n\tif (cmd->redirect_file_name != NULL) {\n\t\tif (pipe(redirect_fd) == -1) {\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\t\n\tint pipe_fd[2];\n\tif (cmd->pipe_args != NULL) {\n\t\tif (pipe(pipe_fd) == -1) {\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\tpid = fork();\n\tif (pid == 0) {\n\t\tif (cmd->pipe_args != NULL) {\n\t\t\tclose(pipe_fd[0]);\n\t\t\tif (dup2(pipe_fd[1], STDOUT_FILENO) == -1) {\n\t\t\t\tfprintf(stderr, \"bhshell: Could not redirect stdout\\n\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tclose(pipe_fd[1]);\n\t\t\tif (cmd->redirect_file_name != NULL) {\n\t\t\t\tclose(redirect_fd[0]);\n\t\t\t\tclose(redirect_fd[1]);\n\t\t\t}\n\t\t}\n\t\tif (cmd->pipe_args == NULL && cmd->redirect_file_name != NULL) {\n\t\t\tclose(redirect_fd[0]);\n\t\t\tif (dup2(redirect_fd[1], STDOUT_FILENO) == -1) {\n\t\t\t\tfprintf(stderr, \"bhshell: Could not redirect stdout to file\\n\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tclose(redirect_fd[1]);\n\t\t} \n\t\t\n\t\tif (execvp(cmd->args[0], cmd->args) == -1) {\n\t\t\tperror(\"bhshell\");\n\t\t}\n\t\t\n\t\t\n\t\texit(EXIT_FAILURE);\n\t} else if (pid < 0) {\n\t\t\n\t\tperror(\"bhshell: Could not create child process\");\n\t\texit(EXIT_FAILURE);\n\t} \n\t\n\tif (cmd->pipe_args != NULL) {\n\t\tpid_t pid_pipe = fork();\n\t\tint pipe_status;\n\t\tif (pid_pipe == 0) {\n\t\t\tif (cmd->redirect_file_name != NULL) {\n\t\t\t\tclose(redirect_fd[0]);\n\t\t\t\tif (dup2(redirect_fd[1], STDOUT_FILENO) == -1) {\n\t\t\t\t\tfprintf(stderr, \"bhshell: Could not redirect stdout to file\\n\");\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t\tclose(redirect_fd[1]);\n\t\t\t}\n\t\t\tclose(pipe_fd[1]);\n\t\t\tif (dup2(pipe_fd[0], STDIN_FILENO) == -1) {\n\t\t\t\tfprintf(stderr, \"bhshell: Could not redirect stdin\\n\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tclose(pipe_fd[0]);\n\t\t\tif (execvp(cmd->pipe_args[0], cmd->pipe_args) == -1) {\n\t\t\t\tperror(\"bhshell\");\n\t\t\t}\n\t\t\texit(EXIT_FAILURE);\n\t\t} else if (pid_pipe < 0) {\n\t\t\tperror(\"bhshell: Could not create child process\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tclose(pipe_fd[0]);\n\t\tclose(pipe_fd[1]);\n\t\tif (cmd->redirect_file_name != NULL) {\n\t\t\twrite_to_redirect(redirect_fd, cmd);\n\t\t}\n\t\tdo {\n\t\t\twaitpid(pid_pipe, &pipe_status, WUNTRACED);\n\t\t\twaitpid(pid, &status, WUNTRACED);\n\t\t} while(!WIFEXITED(status) && !WIFSIGNALED(status) && !WIFEXITED(pipe_status) && !WIFSIGNALED(pipe_status));\n\t\n\t\treturn 1;\n\t} else if (cmd->redirect_file_name != NULL) {\n\t\twrite_to_redirect(redirect_fd, cmd);\n\t}\n\tdo {\n\t\twaitpid(pid, &status, WUNTRACED);\n\t} while(!WIFEXITED(status) && !WIFSIGNALED(status));\n\treturn 1;\n}\nint bhshell_cd(char** args) {\n\tif (args[1] == NULL) {\n\t\tfprintf(stderr, \"bhshell: expected argument to \\\"cd\\\" into\\n\");\n\t} else {\n\t\tif (chdir(args[1]) != 0) {\n\t\t\tperror(\"bhshell\");\n\t\t}\n\t}\n\treturn 1;\n}\nint bhshell_help(char** args) {\n\tprintf(\"A simple shell built to understand how processes work.\\n\");\n\tprintf(\"The following functions are builtin:\\n\");\n\tint count = bhshell_num_builtins();\n\tfor (int i = 0; i < count; i++) {\n\t\tprintf(\"\\t %d. %s\\n\", i + 1, bhshell_builtin_str[i]);\n\t}\n\treturn 1;\n}\nint bhshell_exit(char** args) {\n\treturn 0;\n}\nint bhshell_num_builtins() {\n\treturn sizeof(bhshell_builtin_str) / sizeof(char*);\n}\nvoid write_to_redirect(int redirect_fd[2], command* cmd) {\n\tstr s = { DA_NULL };\n\tchar temp;\n\t\n\tclose(redirect_fd[1]);\n\tint finished = read(redirect_fd[0], &temp, sizeof(char));\n\tif (finished == -1) {\n\t\tclose(redirect_fd[0]);\n\t\tclose(redirect_fd[1]);\n\t\tfree(s.items);\n\t\texit(EXIT_FAILURE);\n\t}\n\twhile (finished != 0) {\n\t\tda_append(&s, temp);\n\t\tfinished = read(redirect_fd[0], &temp, sizeof(char));\n\t}\n\tchar* string = get_string(&s);\n\t\n\tclose(redirect_fd[0]);\n\tFILE* f = fopen(cmd->redirect_file_name, \"w\");\n\tif (!f) {\n\t\tfprintf(stderr, \"Could not open file\\n\");\n\t\tfree(s.items);\n\t\texit(EXIT_FAILURE);\n\t}\n\tsize_t written = fwrite(string, strlen(string), 1, f);\n\tif (written == 0) {\n\t\tfprintf(stderr, \"Could not write to file\\n\");\n\t\tfree(string);\n\t\texit(EXIT_FAILURE);\n\t}\n\tfree(string); \n\tfclose(f);\n}\n", "rtext": "use crate::input::Command;\npub const BUF_SIZE: usize = 64;\n/// Runs the main bhshell loop.\npub fn bhshell_loop() {\nunimplemented!()\n}\n/// Executes the given command.\n/// Returns an integer status code (C equivalent of int).\npub fn bhshell_execute(_cmd: &mut Command) -> i32 {\nunimplemented!()\n}\n/// Launches the given command.\n/// Returns an integer status code (C equivalent of int).\npub fn bhshell_launch(_cmd: &mut Command) -> i32 {\nunimplemented!()\n}\n/// Changes the current directory.\n/// Returns an integer status code (C equivalent of int).\npub fn bhshell_cd(_args: &[String]) -> i32 {\nunimplemented!()\n}\n/// Prints help information.\n/// Returns an integer status code (C equivalent of int).\npub fn bhshell_help(_args: &[String]) -> i32 {\nunimplemented!()\n}\n/// Handles exit request.\n/// Returns an integer status code (C equivalent of int).\npub fn bhshell_exit(_args: &[String]) -> i32 {\nunimplemented!()\n}\n/// Returns the number of built-in commands.\npub fn bhshell_num_builtins() -> i32 {\nunimplemented!()\n}\n/// Writes to a redirected file descriptor array.\n/// In C, this took an array 'int redirect_fd[2]' and a pointer to 'command'.\npub fn write_to_redirect(_redirect_fd: &mut [i32; 2], _cmd: &mut Command) {\nunimplemented!()\n}"}
{"ctext": "// from header\n/*\n#include \"xalloc.h\"\n#ifndef DYNAMICARR_H\n#define DYNAMICARR_H\n#define DA_BUFFER_SIZE 16\n#define DA_NULL .items = NULL, .position = 0, .bufsize = 0\n#define da_append(l, x) \\\n\tdo {\\\n\t\tif ((l)->position >= (l)->bufsize) {\\\n\t\t\tif ((l)->bufsize == 0) (l)->bufsize = DA_BUFFER_SIZE;\\\n\t\t\telse (l)->bufsize *= 2;\\\n\t\t\t(l)->items = xrealloc((l)->items, ((l)->bufsize)*sizeof(*(l)->items));\\\n\t\t}\\\n\t\t(l)->items[(l)->position++] = x;\\\n\t} while(0)\ntypedef struct str {\n\tchar* items;\n\tsize_t position;\n\tsize_t bufsize;\n} str;\nchar* get_string(str* s);\ntypedef struct arg_list {\n\tchar** items;\n\tsize_t position;\n\tsize_t bufsize;\n} arg_list;\nchar** get_args(arg_list* l);\nvoid destroy_args(char** args);\n#endif\n\n*/\n#include <string.h>\n#include \"include/dynamicarr.h\"\n#include \"include/xalloc.h\"\nchar* get_string(str* s) {\n\tda_append(s, '\\0');\n\tchar* string = xmalloc(sizeof(char) * (s->position));\n\tmemcpy(string, s->items, sizeof(char) * s->position);\n\tfree(s->items);\n\ts->position = 0; s->items = NULL; s->bufsize = 0;\n\treturn string;\n}\nvoid destroy_args(char** args) {\n\tif (!args) return;\n\tsize_t i = 0;\n\twhile(args[i] != NULL) {\n\t\tfree(args[i]);\n\t\ti++;\n\t}\n}\nchar** get_args(arg_list* l) {\n\tif (l->position == 0) {\n\t\treturn NULL;\n\t}\n\tda_append(l, NULL);\n\tchar** args = xmalloc(sizeof(char*) * (l->position));\n\tfor (size_t i = 0; i < l->position - 1; i++) {\n\t\tsize_t length = strlen(l->items[i]);\n\t\targs[i] = xmalloc(sizeof(char) * (length + 1));\n\t\tmemcpy(args[i], l->items[i], length + 1);\n\t}\n\targs[l->position - 1] = NULL;\n\treturn args;\n}\n", "rtext": "use crate::xalloc;\npub const DA_BUFFER_SIZE: usize = 16;\n/// Represents a dynamic list of strings in an idiomatic, safe Rust form.\n#[derive(Debug, Default)]\npub struct ArgList {\npub items: Vec<String>,\npub position: usize,\npub bufsize: usize,\n}\n/// Represents a dynamic string in an idiomatic, safe Rust form.\n#[derive(Debug, Default)]\npub struct Str {\npub items: String,\npub position: usize,\npub bufsize: usize,\n}\n/// Returns a new vector of strings derived from the given ArgList.\n/// In C, this was returning a 'char**'.\npub fn get_args(_l: &ArgList) -> Vec<String> {\nunimplemented!()\n}\n/// Returns a new String derived from the given Str.\n/// In C, this was returning a 'char*'.\npub fn get_string(_s: &Str) -> String {\nunimplemented!()\n}\n/// Destroys / frees the given vector of strings.\n/// In C, this was taking 'char** args'.\npub fn destroy_args(_args: Vec<String>) {\nunimplemented!()\n}"}
{"ctext": "// from header\n/*\n#include <stdlib.h>\n#ifndef INPUT_H\n#define INPUT_H\n#define FREE_ON_INVALID(ARGS, PIPE_ARGS, REDIRECT) \\\n\tdo {\\\n\t\tif ((ARGS).position > 0) destroy_args(args.items);\\\n\t\tif ((PIPE_ARGS).position > 0) destroy_args(pipe_args.items);\\\n\t\tif ((REDIRECT)!= NULL) free(redirect);\\\n\t} while(0)\ntypedef struct command {\n\tchar** args;\n\tchar** pipe_args;\n\tchar* redirect_file_name;\n} command;\nchar* bhshell_read_line();\ncommand* bhshell_parse(char* line);\nvoid destroy_command(command* cmd);\ncommand* new_command();\n#endif\n\n*/\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n#include \"include/input.h\"\n#include \"include/dynamicarr.h\"\n#include \"include/xalloc.h\"\nenum ARG_TYPE {\n\tARG,\n\tPIPE_ARG,\n\tREDIRECT\n};\nchar* bhshell_read_line() {\n\tstr s = { DA_NULL };\n\twhile(1) {\n\t\tint c = getchar();\n\t\tif (c == '\\n' || c == EOF) {\n\t\t\tchar* string = get_string(&s);\n\t\t\treturn string;\n\t\t} else {\n\t\t\tda_append(&s, c);\n\t\t}\n\t}\n}\ncommand* bhshell_parse(char* line) {\n\tsize_t length = strlen(line);\n\targ_list args = { DA_NULL };\n\targ_list pipe_args = { DA_NULL };\n\tstr s = { DA_NULL };\n\tchar* redirect = NULL;\n\tenum ARG_TYPE current = ARG;\n\tcommand* cmd = new_command();\n\tfor (size_t i = 0; i < length; i++) {\n\t\tif (line[i] == '\\n' || line[i] == '\\t' || line[i] == ' ') {\n\t\t\tif (s.position > 0) {\n\t\t\t\tchar* string = get_string(&s);\n\t\t\t\tif (current == ARG) {\n\t\t\t\t\tda_append(&args, string);\n\t\t\t\t} else if (current == PIPE_ARG) {\n\t\t\t\t\tda_append(&pipe_args, string);\n\t\t\t\t} else {\n\t\t\t\t\tredirect = string;\t\n\t\t\t\t}\n\t\t\t} \n\t\t\tcontinue;\n\t\t} else if (line[i] == '|') {\n\t\t\tif (s.position > 0) {\n\t\t\t\tchar* string = get_string(&s);\n\t\t\t\tif (current == ARG) {\n\t\t\t\t\tda_append(&args, string);\n\t\t\t\t\tda_append(&args, NULL);\n\t\t\t\t} else {\n\t\t\t\t\tFREE_ON_INVALID(args, pipe_args, redirect);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i + 1 < length && line[i] == '>') {\n\t\t\t\tFREE_ON_INVALID(args, pipe_args, redirect);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcurrent = PIPE_ARG;\n\t\t} else if (line[i] == '>') {\n\t\t\tif (s.position > 0) {\n\t\t\t\tchar* string = get_string(&s);\n\t\t\t\tif (current == ARG) {\n\t\t\t\t\tda_append(&args, string);\n\t\t\t\t\tda_append(&args, NULL);\n\t\t\t\t} else if (current == PIPE_ARG) {\n\t\t\t\t\tda_append(&pipe_args, string);\n\t\t\t\t\tda_append(&pipe_args, NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrent = REDIRECT;\n\t\t} else {\n\t\t\tda_append(&s, line[i]);\n\t\t}\n\t}\n\tif (s.position == 0) {\n\t\tFREE_ON_INVALID(args, pipe_args, redirect);\n\t\treturn NULL;\n\t}\n\tif (s.position > 0) {\n\t\tchar* string = get_string(&s);\n\t\tif (current == ARG) {\n\t\t\tda_append(&args, string);\n\t\t\tda_append(&args, NULL);\n\t\t} else if (current == PIPE_ARG) {\n\t\t\tda_append(&pipe_args, string);\n\t\t\tda_append(&pipe_args, NULL);\n\t\t} else {\n\t\t\tredirect = string;\n\t\t}\n\t} \n\tif (args.position == 0) {\n\t\tFREE_ON_INVALID(args, pipe_args, redirect);\n\t\treturn NULL;\n\t}\n\tcmd->args = args.items;\n\tif (pipe_args.position > 0) {\n\t\tcmd->pipe_args = pipe_args.items;\n\t}\n\tif (redirect != NULL) {\n\t\tcmd->redirect_file_name = redirect;\n\t}\n\treturn cmd;\n}\ncommand* new_command() {\n\tcommand* cmd = xmalloc(sizeof(command));\n\t\n\tcmd->args = NULL;\n\tcmd->pipe_args = NULL;\n\tcmd->redirect_file_name = NULL;\n\treturn cmd;\n}\nvoid destroy_command(command* cmd) {\n\tdestroy_args(cmd->args);\n\tdestroy_args(cmd->pipe_args);\n\tfree(cmd->redirect_file_name);\n\tfree(cmd);\n}\n", "rtext": "use crate::dynamicarr;\n/// Represents a command, including its arguments, pipe-arguments,\n/// and redirection information, in a safe Rust form.\n#[derive(Debug, Default)]\npub struct Command {\npub args: Vec<String>,\npub pipe_args: Vec<String>,\npub redirect_file_name: Option<String>,\n}\n/// Reads a line of input from the user.\n/// In C, this was returning a 'char*'.\npub fn bhshell_read_line() -> String {\nunimplemented!()\n}\n/// Parses a given line into a Command structure.\n/// In C, this was returning a 'command*' for the allocated command.\npub fn bhshell_parse(_line: &str) -> Command {\nunimplemented!()\n}\n/// Cleans up and destroys a Command structure.\n/// In C, this took 'command* cmd' and freed its data.\npub fn destroy_command(_cmd: Command) {\nunimplemented!()\n}\n/// Creates and returns a new Command structure.\n/// In C, this was returning a 'command*'.\npub fn new_command() -> Command {\nunimplemented!()\n}"}
{"ctext": "#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <stdbool.h>\n#include \"include/bhshell.h\"\n#include \"include/input.h\"\nint main(void) {\n\tbhshell_loop();\t\n\treturn EXIT_SUCCESS;\n}\n", "rtext": "/// Entry point of the application.\n/// In C, this was 'int main(void)'.\npub fn main() {\nunimplemented!()\n}"}
{"ctext": "// from header\n/*\n#include <stdlib.h>\nvoid* xmalloc(size_t size);\nvoid* xrealloc(void* ptr, size_t size);\n\n*/\n#include <stdlib.h>\n#include <stdio.h>\n#include \"include/xalloc.h\"\nvoid* xmalloc(size_t size) {\n\tvoid* ptr = malloc(size);\n\tif (!ptr) {\n\t\tfprintf(stderr, \"bhshell: allocation error\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\treturn ptr;\n}\nvoid* xrealloc(void* ptr, size_t size) {\n\tptr = realloc(ptr, size);\n\tif (!ptr) {\n\t\tfprintf(stderr, \"bhshell: allocation error\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\treturn ptr;\n}\n", "rtext": "/// Reallocates a vector of bytes to a new size.\n/// In C, this was 'void* xrealloc(void* ptr, size_t size)'.\npub fn xrealloc(_data: Vec<u8>, _new_size: usize) -> Vec<u8> {\nunimplemented!()\n}\n/// Allocates a new vector of bytes of the specified size.\n/// In C, this was 'void* xmalloc(size_t size)'.\npub fn xmalloc(_size: usize) -> Vec<u8> {\nunimplemented!()\n}"}
